/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AllocationAPIService AllocationAPI service
type AllocationAPIService service

type ApiCreateAllocationRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationCreateRequest *AllocationCreateRequest
}

func (r ApiCreateAllocationRequest) AllocationCreateRequest(allocationCreateRequest AllocationCreateRequest) ApiCreateAllocationRequest {
	r.allocationCreateRequest = &allocationCreateRequest
	return r
}

func (r ApiCreateAllocationRequest) Execute() (*Allocation, *http.Response, error) {
	return r.ApiService.CreateAllocationExecute(r)
}

/*
CreateAllocation Create Allocation

Create an Allocation for the org.

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` role.

Tenant management of Allocation is not supported in MVP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiCreateAllocationRequest
*/
func (a *AllocationAPIService) CreateAllocation(ctx context.Context, org string) ApiCreateAllocationRequest {
	return ApiCreateAllocationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return Allocation
func (a *AllocationAPIService) CreateAllocationExecute(r ApiCreateAllocationRequest) (*Allocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.CreateAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.allocationCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAllocationConstraintRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationId string
	allocationConstraintCreateRequest *AllocationConstraintCreateRequest
}

func (r ApiCreateAllocationConstraintRequest) AllocationConstraintCreateRequest(allocationConstraintCreateRequest AllocationConstraintCreateRequest) ApiCreateAllocationConstraintRequest {
	r.allocationConstraintCreateRequest = &allocationConstraintCreateRequest
	return r
}

func (r ApiCreateAllocationConstraintRequest) Execute() (*AllocationConstraint, *http.Response, error) {
	return r.ApiService.CreateAllocationConstraintExecute(r)
}

/*
CreateAllocationConstraint Create Allocation Constraint

Create an Allocation Constraint for a given Allocation ID.

Org must have an Infrastructure Provider entity and specified Allocation must have been created by the Provider. User must have `FORGE_PROVIDER_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param allocationId ID of the Allocation
 @return ApiCreateAllocationConstraintRequest
*/
func (a *AllocationAPIService) CreateAllocationConstraint(ctx context.Context, org string, allocationId string) ApiCreateAllocationConstraintRequest {
	return ApiCreateAllocationConstraintRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		allocationId: allocationId,
	}
}

// Execute executes the request
//  @return AllocationConstraint
func (a *AllocationAPIService) CreateAllocationConstraintExecute(r ApiCreateAllocationConstraintRequest) (*AllocationConstraint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllocationConstraint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.CreateAllocationConstraint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation/{allocationId}/constraint"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationId"+"}", url.PathEscape(parameterValueToString(r.allocationId, "allocationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.allocationConstraintCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAllocationRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationId string
}

func (r ApiDeleteAllocationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAllocationExecute(r)
}

/*
DeleteAllocation Delete Allocation

Delete an Allocation by ID.

Org must have an Infrastructure Provider entity, specified Allocation must be created by said Provider. Requesting user must have `FORGE_PROVIDER_ADMIN` role.

Tenant management of Allocation is not supported in MVP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param allocationId ID of the Allocation
 @return ApiDeleteAllocationRequest
*/
func (a *AllocationAPIService) DeleteAllocation(ctx context.Context, org string, allocationId string) ApiDeleteAllocationRequest {
	return ApiDeleteAllocationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		allocationId: allocationId,
	}
}

// Execute executes the request
func (a *AllocationAPIService) DeleteAllocationExecute(r ApiDeleteAllocationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.DeleteAllocation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation/{allocationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationId"+"}", url.PathEscape(parameterValueToString(r.allocationId, "allocationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAllocationConstraintRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationId string
	allocationConstraintId string
}

func (r ApiDeleteAllocationConstraintRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAllocationConstraintExecute(r)
}

/*
DeleteAllocationConstraint Delete Allocation Constraint

Delete an existing Allocation Constraint by ID

Org must have an Infrastructure Provider. Specified Allocation must have been created by the Provider and requesting user must have `FORGE_PROVIDER_ADMIN` role.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param allocationId ID of the Allocation
 @param allocationConstraintId ID of the Allocation Constraint
 @return ApiDeleteAllocationConstraintRequest
*/
func (a *AllocationAPIService) DeleteAllocationConstraint(ctx context.Context, org string, allocationId string, allocationConstraintId string) ApiDeleteAllocationConstraintRequest {
	return ApiDeleteAllocationConstraintRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		allocationId: allocationId,
		allocationConstraintId: allocationConstraintId,
	}
}

// Execute executes the request
func (a *AllocationAPIService) DeleteAllocationConstraintExecute(r ApiDeleteAllocationConstraintRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.DeleteAllocationConstraint")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation/{allocationId}/constraint/{allocationConstraintId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationId"+"}", url.PathEscape(parameterValueToString(r.allocationId, "allocationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationConstraintId"+"}", url.PathEscape(parameterValueToString(r.allocationConstraintId, "allocationConstraintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllAllocationRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	infrastructureProviderId *string
	tenantId *string
	siteId *string
	id *string
	resourceType *string
	status *string
	resourceTypeId *string
	constraintType *string
	constraintValue *int32
	query *string
	includeRelation *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter Allocations by Infrastructure Provider ID
func (r ApiGetAllAllocationRequest) InfrastructureProviderId(infrastructureProviderId string) ApiGetAllAllocationRequest {
	r.infrastructureProviderId = &infrastructureProviderId
	return r
}

// Filter Allocations by Tenant ID.  Can be specified multiple times to filter on more than one Tenant ID.
func (r ApiGetAllAllocationRequest) TenantId(tenantId string) ApiGetAllAllocationRequest {
	r.tenantId = &tenantId
	return r
}

// Filter Allocations by Site ID.  Can be specified multiple times to filter on more than one Site ID.
func (r ApiGetAllAllocationRequest) SiteId(siteId string) ApiGetAllAllocationRequest {
	r.siteId = &siteId
	return r
}

// Filter Allocations by ID.  Can be specified multiple times to filter on more than one ID.
func (r ApiGetAllAllocationRequest) Id(id string) ApiGetAllAllocationRequest {
	r.id = &id
	return r
}

// Filter Allocations by Constraint Resource Type.  Can be specified multiple times to filter on more than one Constraint Resource Type.
func (r ApiGetAllAllocationRequest) ResourceType(resourceType string) ApiGetAllAllocationRequest {
	r.resourceType = &resourceType
	return r
}

// Filter Allocations by Status.  Can be specified multiple times to filter on more than one Status.
func (r ApiGetAllAllocationRequest) Status(status string) ApiGetAllAllocationRequest {
	r.status = &status
	return r
}

// Filter Allocations by Constraint Resource Type ID.  Can be specified multiple times to filter on more than one Constraint Resource Type ID.
func (r ApiGetAllAllocationRequest) ResourceTypeId(resourceTypeId string) ApiGetAllAllocationRequest {
	r.resourceTypeId = &resourceTypeId
	return r
}

// Filter Allocations by Constraint Type.  Can be specified multiple times to filter on more than one Constraint Type.
func (r ApiGetAllAllocationRequest) ConstraintType(constraintType string) ApiGetAllAllocationRequest {
	r.constraintType = &constraintType
	return r
}

// Filter Allocations by Constraint Value.  Can be specified multiple times to filter on more than one Constraint Value.
func (r ApiGetAllAllocationRequest) ConstraintValue(constraintValue int32) ApiGetAllAllocationRequest {
	r.constraintValue = &constraintValue
	return r
}

// Search for matches across all Sites. Input will be matched against name, description and status fields
func (r ApiGetAllAllocationRequest) Query(query string) ApiGetAllAllocationRequest {
	r.query = &query
	return r
}

// Related entity to expand
func (r ApiGetAllAllocationRequest) IncludeRelation(includeRelation string) ApiGetAllAllocationRequest {
	r.includeRelation = &includeRelation
	return r
}

// Page number for pagination query
func (r ApiGetAllAllocationRequest) PageNumber(pageNumber int32) ApiGetAllAllocationRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllAllocationRequest) PageSize(pageSize int32) ApiGetAllAllocationRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllAllocationRequest) OrderBy(orderBy string) ApiGetAllAllocationRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllAllocationRequest) Execute() ([]Allocation, *http.Response, error) {
	return r.ApiService.GetAllAllocationExecute(r)
}

/*
GetAllAllocation Retrieve all Allocations

Retrieve all Allocations for the org.

Either `infrastructureProviderId` or `tenantId` query param must be specified.

If `infrastructureProviderId` query param is provided, then org must have an Infrastructure Provider entity and its ID should match the query param value. User must have `FORGE_PROVIDER_ADMIN` role.

If `tenantId` query param is provided, then org must have a Tenant entity and its ID should match the query param value. User must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllAllocationRequest
*/
func (a *AllocationAPIService) GetAllAllocation(ctx context.Context, org string) ApiGetAllAllocationRequest {
	return ApiGetAllAllocationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []Allocation
func (a *AllocationAPIService) GetAllAllocationExecute(r ApiGetAllAllocationRequest) ([]Allocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Allocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.GetAllAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.infrastructureProviderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "infrastructureProviderId", r.infrastructureProviderId, "form", "")
	}
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceType", r.resourceType, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.resourceTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resourceTypeId", r.resourceTypeId, "form", "")
	}
	if r.constraintType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraintType", r.constraintType, "form", "")
	}
	if r.constraintValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraintValue", r.constraintValue, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", defaultValue, "form", "")
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllAllocationConstraintRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationId string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Page number for pagination query
func (r ApiGetAllAllocationConstraintRequest) PageNumber(pageNumber int32) ApiGetAllAllocationConstraintRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllAllocationConstraintRequest) PageSize(pageSize int32) ApiGetAllAllocationConstraintRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllAllocationConstraintRequest) OrderBy(orderBy string) ApiGetAllAllocationConstraintRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllAllocationConstraintRequest) Execute() ([]AllocationConstraint, *http.Response, error) {
	return r.ApiService.GetAllAllocationConstraintExecute(r)
}

/*
GetAllAllocationConstraint Retrieve all Allocation Constraints

Retrieve all Allocation Constraints for a given Allocation ID.

If org has an Infrastructure Provider entity, then specified Allocation must have been created by the Provider and requesting user must have `FORGE_PROVIDER_ADMIN` role.

If org does not have an Infrastructure Provider entity but has a Tenant entity, then specified Allocation must belong to the Tenant and requesting user must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param allocationId ID of the Allocation
 @return ApiGetAllAllocationConstraintRequest
*/
func (a *AllocationAPIService) GetAllAllocationConstraint(ctx context.Context, org string, allocationId string) ApiGetAllAllocationConstraintRequest {
	return ApiGetAllAllocationConstraintRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		allocationId: allocationId,
	}
}

// Execute executes the request
//  @return []AllocationConstraint
func (a *AllocationAPIService) GetAllAllocationConstraintExecute(r ApiGetAllAllocationConstraintRequest) ([]AllocationConstraint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AllocationConstraint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.GetAllAllocationConstraint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation/{allocationId}/constraint"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationId"+"}", url.PathEscape(parameterValueToString(r.allocationId, "allocationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", defaultValue, "form", "")
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllocationRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationId string
	infrastructureProviderId *string
	tenantId *string
	includeRelation *string
}

// Filter Allocations by Infrastructure Provider ID
func (r ApiGetAllocationRequest) InfrastructureProviderId(infrastructureProviderId string) ApiGetAllocationRequest {
	r.infrastructureProviderId = &infrastructureProviderId
	return r
}

// Filter Allocations by Tenant ID
func (r ApiGetAllocationRequest) TenantId(tenantId string) ApiGetAllocationRequest {
	r.tenantId = &tenantId
	return r
}

// Related entity to expand
func (r ApiGetAllocationRequest) IncludeRelation(includeRelation string) ApiGetAllocationRequest {
	r.includeRelation = &includeRelation
	return r
}

func (r ApiGetAllocationRequest) Execute() (*Allocation, *http.Response, error) {
	return r.ApiService.GetAllocationExecute(r)
}

/*
GetAllocation Retrieve Allocation

Retrieve Allocation by ID

Allocation must belong either to the Provider associated with the org or the Tenant associated with the org.

User must have `FORGE_PROVIDER_ADMIN`, `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param allocationId ID of the Allocation
 @return ApiGetAllocationRequest
*/
func (a *AllocationAPIService) GetAllocation(ctx context.Context, org string, allocationId string) ApiGetAllocationRequest {
	return ApiGetAllocationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		allocationId: allocationId,
	}
}

// Execute executes the request
//  @return Allocation
func (a *AllocationAPIService) GetAllocationExecute(r ApiGetAllocationRequest) (*Allocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.GetAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation/{allocationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationId"+"}", url.PathEscape(parameterValueToString(r.allocationId, "allocationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.infrastructureProviderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "infrastructureProviderId", r.infrastructureProviderId, "form", "")
	}
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllocationConstraintRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationId string
	allocationConstraintId string
}

func (r ApiGetAllocationConstraintRequest) Execute() ([]AllocationConstraint, *http.Response, error) {
	return r.ApiService.GetAllocationConstraintExecute(r)
}

/*
GetAllocationConstraint Retrieve Allocation Constraint

Retrieve an Allocation Constraint for a given Allocation ID.

If org has an Infrastructure Provider entity, then specified Allocation must have been created by the Provider and requesting user must have `FORGE_PROVIDER_ADMIN` role.

If org does not have an Infrastructure Provider entity but has a Tenant entity, then specified Allocation must belong to the Tenant and requesting user must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param allocationId ID of the Allocation
 @param allocationConstraintId ID of the Allocation Constraint
 @return ApiGetAllocationConstraintRequest
*/
func (a *AllocationAPIService) GetAllocationConstraint(ctx context.Context, org string, allocationId string, allocationConstraintId string) ApiGetAllocationConstraintRequest {
	return ApiGetAllocationConstraintRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		allocationId: allocationId,
		allocationConstraintId: allocationConstraintId,
	}
}

// Execute executes the request
//  @return []AllocationConstraint
func (a *AllocationAPIService) GetAllocationConstraintExecute(r ApiGetAllocationConstraintRequest) ([]AllocationConstraint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AllocationConstraint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.GetAllocationConstraint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation/{allocationId}/constraint/{allocationConstraintId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationId"+"}", url.PathEscape(parameterValueToString(r.allocationId, "allocationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationConstraintId"+"}", url.PathEscape(parameterValueToString(r.allocationConstraintId, "allocationConstraintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAllocationRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationId string
	allocationUpdateRequest *AllocationUpdateRequest
}

func (r ApiUpdateAllocationRequest) AllocationUpdateRequest(allocationUpdateRequest AllocationUpdateRequest) ApiUpdateAllocationRequest {
	r.allocationUpdateRequest = &allocationUpdateRequest
	return r
}

func (r ApiUpdateAllocationRequest) Execute() (*Allocation, *http.Response, error) {
	return r.ApiService.UpdateAllocationExecute(r)
}

/*
UpdateAllocation Update Allocation

Update an existing Allocation

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` role. Provider must own the Allocation.

Tenant management of Allocation is not supported in MVP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param allocationId ID of the Allocation
 @return ApiUpdateAllocationRequest
*/
func (a *AllocationAPIService) UpdateAllocation(ctx context.Context, org string, allocationId string) ApiUpdateAllocationRequest {
	return ApiUpdateAllocationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		allocationId: allocationId,
	}
}

// Execute executes the request
//  @return Allocation
func (a *AllocationAPIService) UpdateAllocationExecute(r ApiUpdateAllocationRequest) (*Allocation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Allocation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.UpdateAllocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation/{allocationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationId"+"}", url.PathEscape(parameterValueToString(r.allocationId, "allocationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.allocationUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAllocationConstraintRequest struct {
	ctx context.Context
	ApiService *AllocationAPIService
	org string
	allocationId string
	allocationConstraintId string
	allocationConstraintUpdateRequest *AllocationConstraintUpdateRequest
}

func (r ApiUpdateAllocationConstraintRequest) AllocationConstraintUpdateRequest(allocationConstraintUpdateRequest AllocationConstraintUpdateRequest) ApiUpdateAllocationConstraintRequest {
	r.allocationConstraintUpdateRequest = &allocationConstraintUpdateRequest
	return r
}

func (r ApiUpdateAllocationConstraintRequest) Execute() (*AllocationConstraint, *http.Response, error) {
	return r.ApiService.UpdateAllocationConstraintExecute(r)
}

/*
UpdateAllocationConstraint Update Allocation Constraint

Update an existing Allocation Constraint by ID

Org must have an Infrastructure Provider. Specified Allocation must have been created by the Provider and requesting user must have `FORGE_PROVIDER_ADMIN` role.

Modifying allocations may not be possible if Tenant has started utilizing resources from this allocation.

In case of InstanceType resource, `constraintValue` can be incremented anytime, but not decremented if it requires decommissioning Tenant resources.

In case of IPBlock resource, `constraintValue` can not be modified if Tenant resources are using IPs from the block.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param allocationId ID of the Allocation
 @param allocationConstraintId ID of the Allocation Constraint
 @return ApiUpdateAllocationConstraintRequest
*/
func (a *AllocationAPIService) UpdateAllocationConstraint(ctx context.Context, org string, allocationId string, allocationConstraintId string) ApiUpdateAllocationConstraintRequest {
	return ApiUpdateAllocationConstraintRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		allocationId: allocationId,
		allocationConstraintId: allocationConstraintId,
	}
}

// Execute executes the request
//  @return AllocationConstraint
func (a *AllocationAPIService) UpdateAllocationConstraintExecute(r ApiUpdateAllocationConstraintRequest) (*AllocationConstraint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllocationConstraint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllocationAPIService.UpdateAllocationConstraint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/allocation/{allocationId}/constraint/{allocationConstraintId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationId"+"}", url.PathEscape(parameterValueToString(r.allocationId, "allocationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"allocationConstraintId"+"}", url.PathEscape(parameterValueToString(r.allocationConstraintId, "allocationConstraintId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.allocationConstraintUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
