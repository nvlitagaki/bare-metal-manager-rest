/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InfiniBandPartitionAPIService InfiniBandPartitionAPI service
type InfiniBandPartitionAPIService service

type ApiCreateInfinibandPartitionRequest struct {
	ctx context.Context
	ApiService *InfiniBandPartitionAPIService
	org string
	infiniBandPartitionCreateRequest *InfiniBandPartitionCreateRequest
}

func (r ApiCreateInfinibandPartitionRequest) InfiniBandPartitionCreateRequest(infiniBandPartitionCreateRequest InfiniBandPartitionCreateRequest) ApiCreateInfinibandPartitionRequest {
	r.infiniBandPartitionCreateRequest = &infiniBandPartitionCreateRequest
	return r
}

func (r ApiCreateInfinibandPartitionRequest) Execute() (*InfiniBandPartition, *http.Response, error) {
	return r.ApiService.CreateInfinibandPartitionExecute(r)
}

/*
CreateInfinibandPartition Create InfiniBand Partition

Create an InfiniBand Partition for the org.

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` authorization role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiCreateInfinibandPartitionRequest
*/
func (a *InfiniBandPartitionAPIService) CreateInfinibandPartition(ctx context.Context, org string) ApiCreateInfinibandPartitionRequest {
	return ApiCreateInfinibandPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return InfiniBandPartition
func (a *InfiniBandPartitionAPIService) CreateInfinibandPartitionExecute(r ApiCreateInfinibandPartitionRequest) (*InfiniBandPartition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InfiniBandPartition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfiniBandPartitionAPIService.CreateInfinibandPartition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/infiniband-partition"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.infiniBandPartitionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteInfinibandPartitionRequest struct {
	ctx context.Context
	ApiService *InfiniBandPartitionAPIService
	org string
	infiniBandPartitionId string
}

func (r ApiDeleteInfinibandPartitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteInfinibandPartitionExecute(r)
}

/*
DeleteInfinibandPartition Delete InfiniBand Partition

Delete a specific InfiniBand Partition by ID.

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` role.

Tenant must own the Partition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param infiniBandPartitionId ID of the InfiniBand Partition
 @return ApiDeleteInfinibandPartitionRequest
*/
func (a *InfiniBandPartitionAPIService) DeleteInfinibandPartition(ctx context.Context, org string, infiniBandPartitionId string) ApiDeleteInfinibandPartitionRequest {
	return ApiDeleteInfinibandPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		infiniBandPartitionId: infiniBandPartitionId,
	}
}

// Execute executes the request
func (a *InfiniBandPartitionAPIService) DeleteInfinibandPartitionExecute(r ApiDeleteInfinibandPartitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfiniBandPartitionAPIService.DeleteInfinibandPartition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/infiniband-partition/{infiniBandPartitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"infiniBandPartitionId"+"}", url.PathEscape(parameterValueToString(r.infiniBandPartitionId, "infiniBandPartitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllInfinibandPartitionRequest struct {
	ctx context.Context
	ApiService *InfiniBandPartitionAPIService
	org string
	siteId *string
	status *string
	query *string
	includeRelation *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter Partitions by Site
func (r ApiGetAllInfinibandPartitionRequest) SiteId(siteId string) ApiGetAllInfinibandPartitionRequest {
	r.siteId = &siteId
	return r
}

// Filter Partitions by Status
func (r ApiGetAllInfinibandPartitionRequest) Status(status string) ApiGetAllInfinibandPartitionRequest {
	r.status = &status
	return r
}

// Search for matches across all Sites. Input will be matched against name, description and status fields
func (r ApiGetAllInfinibandPartitionRequest) Query(query string) ApiGetAllInfinibandPartitionRequest {
	r.query = &query
	return r
}

// Related entity to expand
func (r ApiGetAllInfinibandPartitionRequest) IncludeRelation(includeRelation string) ApiGetAllInfinibandPartitionRequest {
	r.includeRelation = &includeRelation
	return r
}

// Page number for pagination query
func (r ApiGetAllInfinibandPartitionRequest) PageNumber(pageNumber int32) ApiGetAllInfinibandPartitionRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllInfinibandPartitionRequest) PageSize(pageSize int32) ApiGetAllInfinibandPartitionRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllInfinibandPartitionRequest) OrderBy(orderBy string) ApiGetAllInfinibandPartitionRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllInfinibandPartitionRequest) Execute() ([]InfiniBandPartition, *http.Response, error) {
	return r.ApiService.GetAllInfinibandPartitionExecute(r)
}

/*
GetAllInfinibandPartition Retrieve all InfiniBand Partitions

Retrieve all InfiniBand Partitions for the org

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllInfinibandPartitionRequest
*/
func (a *InfiniBandPartitionAPIService) GetAllInfinibandPartition(ctx context.Context, org string) ApiGetAllInfinibandPartitionRequest {
	return ApiGetAllInfinibandPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []InfiniBandPartition
func (a *InfiniBandPartitionAPIService) GetAllInfinibandPartitionExecute(r ApiGetAllInfinibandPartitionRequest) ([]InfiniBandPartition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InfiniBandPartition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfiniBandPartitionAPIService.GetAllInfinibandPartition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/infiniband-partition"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInfinibandPartitionRequest struct {
	ctx context.Context
	ApiService *InfiniBandPartitionAPIService
	org string
	infiniBandPartitionId string
	includeRelation *string
}

// Related entity to expand
func (r ApiGetInfinibandPartitionRequest) IncludeRelation(includeRelation string) ApiGetInfinibandPartitionRequest {
	r.includeRelation = &includeRelation
	return r
}

func (r ApiGetInfinibandPartitionRequest) Execute() (*InfiniBandPartition, *http.Response, error) {
	return r.ApiService.GetInfinibandPartitionExecute(r)
}

/*
GetInfinibandPartition Retrieve InfiniBand Partition

Retrieve a specific InfiniBand Partition

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` role.

Tenant must own the Partition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param infiniBandPartitionId ID of the InfiniBand Partition
 @return ApiGetInfinibandPartitionRequest
*/
func (a *InfiniBandPartitionAPIService) GetInfinibandPartition(ctx context.Context, org string, infiniBandPartitionId string) ApiGetInfinibandPartitionRequest {
	return ApiGetInfinibandPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		infiniBandPartitionId: infiniBandPartitionId,
	}
}

// Execute executes the request
//  @return InfiniBandPartition
func (a *InfiniBandPartitionAPIService) GetInfinibandPartitionExecute(r ApiGetInfinibandPartitionRequest) (*InfiniBandPartition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InfiniBandPartition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfiniBandPartitionAPIService.GetInfinibandPartition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/infiniband-partition/{infiniBandPartitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"infiniBandPartitionId"+"}", url.PathEscape(parameterValueToString(r.infiniBandPartitionId, "infiniBandPartitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInfinibandPartitionRequest struct {
	ctx context.Context
	ApiService *InfiniBandPartitionAPIService
	org string
	infiniBandPartitionId string
	infiniBandPartitionUpdateRequest *InfiniBandPartitionUpdateRequest
}

func (r ApiUpdateInfinibandPartitionRequest) InfiniBandPartitionUpdateRequest(infiniBandPartitionUpdateRequest InfiniBandPartitionUpdateRequest) ApiUpdateInfinibandPartitionRequest {
	r.infiniBandPartitionUpdateRequest = &infiniBandPartitionUpdateRequest
	return r
}

func (r ApiUpdateInfinibandPartitionRequest) Execute() (*InfiniBandPartition, *http.Response, error) {
	return r.ApiService.UpdateInfinibandPartitionExecute(r)
}

/*
UpdateInfinibandPartition Update InfiniBand Partition

Update an existing InfiniBand Partition

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` authorization role.

Tenant must own the Partition.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param infiniBandPartitionId ID of the InfiniBand Partition
 @return ApiUpdateInfinibandPartitionRequest
*/
func (a *InfiniBandPartitionAPIService) UpdateInfinibandPartition(ctx context.Context, org string, infiniBandPartitionId string) ApiUpdateInfinibandPartitionRequest {
	return ApiUpdateInfinibandPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		infiniBandPartitionId: infiniBandPartitionId,
	}
}

// Execute executes the request
//  @return InfiniBandPartition
func (a *InfiniBandPartitionAPIService) UpdateInfinibandPartitionExecute(r ApiUpdateInfinibandPartitionRequest) (*InfiniBandPartition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InfiniBandPartition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InfiniBandPartitionAPIService.UpdateInfinibandPartition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/infiniband-partition/{infiniBandPartitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"infiniBandPartitionId"+"}", url.PathEscape(parameterValueToString(r.infiniBandPartitionId, "infiniBandPartitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.infiniBandPartitionUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
