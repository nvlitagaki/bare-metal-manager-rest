/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MachineAPIService MachineAPI service
type MachineAPIService service

type ApiDeleteMachineRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	org string
	machineId string
}

func (r ApiDeleteMachineRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMachineExecute(r)
}

/*
DeleteMachine Delete a Machine from a Site

Org must have an Infrastructure Provider entity. Machine must belong to the Provider. User must have FORGE_PROVIDER_ADMIN authorization role. Machine must meet certain criteria to be eligible for deletion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param machineId ID of the Machine
 @return ApiDeleteMachineRequest
*/
func (a *MachineAPIService) DeleteMachine(ctx context.Context, org string, machineId string) ApiDeleteMachineRequest {
	return ApiDeleteMachineRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		machineId: machineId,
	}
}

// Execute executes the request
func (a *MachineAPIService) DeleteMachineExecute(r ApiDeleteMachineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.DeleteMachine")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine/{machineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllMachineRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	org string
	siteId *string
	id *string
	hasInstanceType *bool
	instanceTypeId *string
	includeMetadata *bool
	status *string
	capabilityType *string
	capabilityName *string
	hwSkuDeviceType *string
	query *string
	includeRelation *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter Machines by Site ID
func (r ApiGetAllMachineRequest) SiteId(siteId string) ApiGetAllMachineRequest {
	r.siteId = &siteId
	return r
}

// Filter Machines by ID.  Can be specified multiple times to filter on more than one ID.
func (r ApiGetAllMachineRequest) Id(id string) ApiGetAllMachineRequest {
	r.id = &id
	return r
}

// Filter Machines that have been assigned an Instance Type. siteId must be specified when using this param.
func (r ApiGetAllMachineRequest) HasInstanceType(hasInstanceType bool) ApiGetAllMachineRequest {
	r.hasInstanceType = &hasInstanceType
	return r
}

// Filter Machines by Instance Type ID.  Can be specified multiple times to filter on more than one Instance Type ID.
func (r ApiGetAllMachineRequest) InstanceTypeId(instanceTypeId string) ApiGetAllMachineRequest {
	r.instanceTypeId = &instanceTypeId
	return r
}

// Include Machine metadata e.g. BMC, DPU, GPU and Interface data. Can only be requested by Provider.
func (r ApiGetAllMachineRequest) IncludeMetadata(includeMetadata bool) ApiGetAllMachineRequest {
	r.includeMetadata = &includeMetadata
	return r
}

// Filter Machines by Status.  Can be specified multiple times to filter on more than one Status.
func (r ApiGetAllMachineRequest) Status(status string) ApiGetAllMachineRequest {
	r.status = &status
	return r
}

// Filter Machines by Capability Type
func (r ApiGetAllMachineRequest) CapabilityType(capabilityType string) ApiGetAllMachineRequest {
	r.capabilityType = &capabilityType
	return r
}

// Filter Machines by Capability Name.  Can be specified multiple times to filter on more than one Capability Name.
func (r ApiGetAllMachineRequest) CapabilityName(capabilityName string) ApiGetAllMachineRequest {
	r.capabilityName = &capabilityName
	return r
}

// Filter Machines by hardware SKU Device Type. Example values: \&quot;gpu\&quot;, \&quot;cpu\&quot;, \&quot;storage\&quot;, \&quot;cache\&quot;
func (r ApiGetAllMachineRequest) HwSkuDeviceType(hwSkuDeviceType string) ApiGetAllMachineRequest {
	r.hwSkuDeviceType = &hwSkuDeviceType
	return r
}

// Provide query to search for matches. Input will be matched against Machine ID, vendor, product name, hostname and status
func (r ApiGetAllMachineRequest) Query(query string) ApiGetAllMachineRequest {
	r.query = &query
	return r
}

// Related entity to expand
func (r ApiGetAllMachineRequest) IncludeRelation(includeRelation string) ApiGetAllMachineRequest {
	r.includeRelation = &includeRelation
	return r
}

// Page number for pagination query
func (r ApiGetAllMachineRequest) PageNumber(pageNumber int32) ApiGetAllMachineRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllMachineRequest) PageSize(pageSize int32) ApiGetAllMachineRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllMachineRequest) OrderBy(orderBy string) ApiGetAllMachineRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllMachineRequest) Execute() ([]Machine, *http.Response, error) {
	return r.ApiService.GetAllMachineExecute(r)
}

/*
GetAllMachine Retrieve all Machines

Get all Machines for Infrastructure Provider.

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` authorization role.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllMachineRequest
*/
func (a *MachineAPIService) GetAllMachine(ctx context.Context, org string) ApiGetAllMachineRequest {
	return ApiGetAllMachineRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []Machine
func (a *MachineAPIService) GetAllMachineExecute(r ApiGetAllMachineRequest) ([]Machine, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Machine
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.GetAllMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.hasInstanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasInstanceType", r.hasInstanceType, "form", "")
	}
	if r.instanceTypeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceTypeId", r.instanceTypeId, "form", "")
	}
	if r.includeMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMetadata", r.includeMetadata, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.capabilityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "capabilityType", r.capabilityType, "form", "")
	}
	if r.capabilityName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "capabilityName", r.capabilityName, "form", "")
	}
	if r.hwSkuDeviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hwSkuDeviceType", r.hwSkuDeviceType, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllMachineCapabilitiesRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	siteId *string
	org string
	hasInstanceType *bool
	type_ *string
	name *string
	frequency *string
	capacity *string
	vendor *string
	inactiveDevices *string
	count *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter Capabilities by Machines from a particular Site
func (r ApiGetAllMachineCapabilitiesRequest) SiteId(siteId string) ApiGetAllMachineCapabilitiesRequest {
	r.siteId = &siteId
	return r
}

// Filter Capabilities by Machines that have an Instance Type
func (r ApiGetAllMachineCapabilitiesRequest) HasInstanceType(hasInstanceType bool) ApiGetAllMachineCapabilitiesRequest {
	r.hasInstanceType = &hasInstanceType
	return r
}

// Filter Capabilities by Type
func (r ApiGetAllMachineCapabilitiesRequest) Type_(type_ string) ApiGetAllMachineCapabilitiesRequest {
	r.type_ = &type_
	return r
}

// Filter Capabilities by Name
func (r ApiGetAllMachineCapabilitiesRequest) Name(name string) ApiGetAllMachineCapabilitiesRequest {
	r.name = &name
	return r
}

// Filter Capabilities by Frequency value
func (r ApiGetAllMachineCapabilitiesRequest) Frequency(frequency string) ApiGetAllMachineCapabilitiesRequest {
	r.frequency = &frequency
	return r
}

// Filter Capabilities by Capacity value
func (r ApiGetAllMachineCapabilitiesRequest) Capacity(capacity string) ApiGetAllMachineCapabilitiesRequest {
	r.capacity = &capacity
	return r
}

// Filter Capabilities by Vendor
func (r ApiGetAllMachineCapabilitiesRequest) Vendor(vendor string) ApiGetAllMachineCapabilitiesRequest {
	r.vendor = &vendor
	return r
}

// Filter Capabilities by Inactive Devices value. Since the value is an array, multiple query params should be specified in correct order in order to filter. For example, to filter for [1, 3], specify inactiveDevices&#x3D;1&amp;inactiveDevices&#x3D;3
func (r ApiGetAllMachineCapabilitiesRequest) InactiveDevices(inactiveDevices string) ApiGetAllMachineCapabilitiesRequest {
	r.inactiveDevices = &inactiveDevices
	return r
}

// Filter Capabilities by Count
func (r ApiGetAllMachineCapabilitiesRequest) Count(count string) ApiGetAllMachineCapabilitiesRequest {
	r.count = &count
	return r
}

// Page number for pagination query
func (r ApiGetAllMachineCapabilitiesRequest) PageNumber(pageNumber int32) ApiGetAllMachineCapabilitiesRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllMachineCapabilitiesRequest) PageSize(pageSize int32) ApiGetAllMachineCapabilitiesRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllMachineCapabilitiesRequest) OrderBy(orderBy string) ApiGetAllMachineCapabilitiesRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllMachineCapabilitiesRequest) Execute() ([]MachineCapability, *http.Response, error) {
	return r.ApiService.GetAllMachineCapabilitiesExecute(r)
}

/*
GetAllMachineCapabilities Retrieve all Machine Capabilities

Get all distinct Machine Capabilities across all Machines

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` authorization role.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllMachineCapabilitiesRequest
*/
func (a *MachineAPIService) GetAllMachineCapabilities(ctx context.Context, org string) ApiGetAllMachineCapabilitiesRequest {
	return ApiGetAllMachineCapabilitiesRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []MachineCapability
func (a *MachineAPIService) GetAllMachineCapabilitiesExecute(r ApiGetAllMachineCapabilitiesRequest) ([]MachineCapability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MachineCapability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.GetAllMachineCapabilities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine-capability"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	if r.hasInstanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasInstanceType", r.hasInstanceType, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.frequency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "frequency", r.frequency, "form", "")
	}
	if r.capacity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "capacity", r.capacity, "form", "")
	}
	if r.vendor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vendor", r.vendor, "form", "")
	}
	if r.inactiveDevices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inactiveDevices", r.inactiveDevices, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMachineRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	org string
	machineId string
	includeRelation *string
	includeMetadata *bool
}

// Related entity to expand
func (r ApiGetMachineRequest) IncludeRelation(includeRelation string) ApiGetMachineRequest {
	r.includeRelation = &includeRelation
	return r
}

// Include Machine metadata e.g. BMC, DPU, GPU and Interface data. Can only be requested by Provider.
func (r ApiGetMachineRequest) IncludeMetadata(includeMetadata bool) ApiGetMachineRequest {
	r.includeMetadata = &includeMetadata
	return r
}

func (r ApiGetMachineRequest) Execute() (*Machine, *http.Response, error) {
	return r.ApiService.GetMachineExecute(r)
}

/*
GetMachine Retrieve a Machine

Org must have either an Infrastructure Provider entity or a Tenant entity.

If org has an Infrastructure Provider entity, then a user with `FORGE_PROVIDER_ADMIN` role can request details for any Machine on any Site owned by the Provider.

If org has a Tenant entity, then a user with `FORGE_TENANT_ADMIN` role can request details for any Machine associated with Tenant's active Instances.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param machineId ID of the Machine
 @return ApiGetMachineRequest
*/
func (a *MachineAPIService) GetMachine(ctx context.Context, org string, machineId string) ApiGetMachineRequest {
	return ApiGetMachineRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return Machine
func (a *MachineAPIService) GetMachineExecute(r ApiGetMachineRequest) (*Machine, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Machine
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.GetMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine/{machineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.includeMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMetadata", r.includeMetadata, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMachineGpuStatsRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	siteId *string
	org string
}

// ID of the Site
func (r ApiGetMachineGpuStatsRequest) SiteId(siteId string) ApiGetMachineGpuStatsRequest {
	r.siteId = &siteId
	return r
}

func (r ApiGetMachineGpuStatsRequest) Execute() ([]MachineGPUStats, *http.Response, error) {
	return r.ApiService.GetMachineGpuStatsExecute(r)
}

/*
GetMachineGpuStats Retrieve GPU stats for machines at a site

Returns GPU summary stats grouped by GPU name for machines at the specified site.

User must have `FORGE_PROVIDER_ADMIN` authorization role. The specified site must belong to the Provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetMachineGpuStatsRequest
*/
func (a *MachineAPIService) GetMachineGpuStats(ctx context.Context, org string) ApiGetMachineGpuStatsRequest {
	return ApiGetMachineGpuStatsRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []MachineGPUStats
func (a *MachineAPIService) GetMachineGpuStatsExecute(r ApiGetMachineGpuStatsRequest) ([]MachineGPUStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MachineGPUStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.GetMachineGpuStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine/gpu/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMachineInstanceTypeStatsRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	siteId *string
	org string
}

// ID of the Site
func (r ApiGetMachineInstanceTypeStatsRequest) SiteId(siteId string) ApiGetMachineInstanceTypeStatsRequest {
	r.siteId = &siteId
	return r
}

func (r ApiGetMachineInstanceTypeStatsRequest) Execute() ([]MachineInstanceTypeStats, *http.Response, error) {
	return r.ApiService.GetMachineInstanceTypeStatsExecute(r)
}

/*
GetMachineInstanceTypeStats Retrieve detailed per-instance-type machine stats for a site

Returns machine stats for each instance type including allocation details and tenant breakdown.

User must have `FORGE_PROVIDER_ADMIN` authorization role. The specified site must belong to the Provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetMachineInstanceTypeStatsRequest
*/
func (a *MachineAPIService) GetMachineInstanceTypeStats(ctx context.Context, org string) ApiGetMachineInstanceTypeStatsRequest {
	return ApiGetMachineInstanceTypeStatsRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []MachineInstanceTypeStats
func (a *MachineAPIService) GetMachineInstanceTypeStatsExecute(r ApiGetMachineInstanceTypeStatsRequest) ([]MachineInstanceTypeStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MachineInstanceTypeStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.GetMachineInstanceTypeStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine/instance-type/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMachineInstanceTypeStatsSummaryRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	siteId *string
	org string
}

// ID of the Site
func (r ApiGetMachineInstanceTypeStatsSummaryRequest) SiteId(siteId string) ApiGetMachineInstanceTypeStatsSummaryRequest {
	r.siteId = &siteId
	return r
}

func (r ApiGetMachineInstanceTypeStatsSummaryRequest) Execute() (*MachineInstanceTypeSummary, *http.Response, error) {
	return r.ApiService.GetMachineInstanceTypeStatsSummaryExecute(r)
}

/*
GetMachineInstanceTypeStatsSummary Retrieve machine instance type assignment summary for a site

Returns machine counts grouped by assigned (has instance type) vs unassigned, broken down by status.

User must have `FORGE_PROVIDER_ADMIN` authorization role. The specified site must belong to the Provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetMachineInstanceTypeStatsSummaryRequest
*/
func (a *MachineAPIService) GetMachineInstanceTypeStatsSummary(ctx context.Context, org string) ApiGetMachineInstanceTypeStatsSummaryRequest {
	return ApiGetMachineInstanceTypeStatsSummaryRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return MachineInstanceTypeSummary
func (a *MachineAPIService) GetMachineInstanceTypeStatsSummaryExecute(r ApiGetMachineInstanceTypeStatsSummaryRequest) (*MachineInstanceTypeSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MachineInstanceTypeSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.GetMachineInstanceTypeStatsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine/instance-type/stats/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMachineStatusHistoryRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	org string
	machineId string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Page number for pagination query
func (r ApiGetMachineStatusHistoryRequest) PageNumber(pageNumber int32) ApiGetMachineStatusHistoryRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetMachineStatusHistoryRequest) PageSize(pageSize int32) ApiGetMachineStatusHistoryRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetMachineStatusHistoryRequest) OrderBy(orderBy string) ApiGetMachineStatusHistoryRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetMachineStatusHistoryRequest) Execute() ([]StatusDetail, *http.Response, error) {
	return r.ApiService.GetMachineStatusHistoryExecute(r)
}

/*
GetMachineStatusHistory Retrieve Machine status history

Org must have either an Infrastructure Provider entity or a Tenant entity.

If org has an Infrastructure Provider entity, then a user with `FORGE_PROVIDER_ADMIN` role can request details for any Machine on any Site owned by the Provider.

If org has a Tenant entity, then a user with `FORGE_TENANT_ADMIN` role can request details for any Machine associated with Tenant's active Instances.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param machineId ID of the Machine
 @return ApiGetMachineStatusHistoryRequest
*/
func (a *MachineAPIService) GetMachineStatusHistory(ctx context.Context, org string, machineId string) ApiGetMachineStatusHistoryRequest {
	return ApiGetMachineStatusHistoryRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return []StatusDetail
func (a *MachineAPIService) GetMachineStatusHistoryExecute(r ApiGetMachineStatusHistoryRequest) ([]StatusDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StatusDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.GetMachineStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine/{machineId}/status-history"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMachineRequest struct {
	ctx context.Context
	ApiService *MachineAPIService
	org string
	machineId string
	machineUpdateRequest *MachineUpdateRequest
}

func (r ApiUpdateMachineRequest) MachineUpdateRequest(machineUpdateRequest MachineUpdateRequest) ApiUpdateMachineRequest {
	r.machineUpdateRequest = &machineUpdateRequest
	return r
}

func (r ApiUpdateMachineRequest) Execute() (*Machine, *http.Response, error) {
	return r.ApiService.UpdateMachineExecute(r)
}

/*
UpdateMachine Update Machine

Update a Machine

Instance Type attribute updates, maintenance attribute updates and labels updates must be specified in separate requests. They cannot be processed at the same time.

Some attributes can only be updated by Provider, while others can be updated by Provider or a Privileged Tenant.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param machineId ID of the Machine
 @return ApiUpdateMachineRequest
*/
func (a *MachineAPIService) UpdateMachine(ctx context.Context, org string, machineId string) ApiUpdateMachineRequest {
	return ApiUpdateMachineRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		machineId: machineId,
	}
}

// Execute executes the request
//  @return Machine
func (a *MachineAPIService) UpdateMachineExecute(r ApiUpdateMachineRequest) (*Machine, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Machine
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MachineAPIService.UpdateMachine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/machine/{machineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineId"+"}", url.PathEscape(parameterValueToString(r.machineId, "machineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.machineUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
