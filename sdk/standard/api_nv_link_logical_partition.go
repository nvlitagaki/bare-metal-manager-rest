/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// NVLinkLogicalPartitionAPIService NVLinkLogicalPartitionAPI service
type NVLinkLogicalPartitionAPIService service

type ApiCreateNvlinkLogicalPartitionRequest struct {
	ctx context.Context
	ApiService *NVLinkLogicalPartitionAPIService
	org string
	nVLinkLogicalPartitionCreateRequest *NVLinkLogicalPartitionCreateRequest
}

func (r ApiCreateNvlinkLogicalPartitionRequest) NVLinkLogicalPartitionCreateRequest(nVLinkLogicalPartitionCreateRequest NVLinkLogicalPartitionCreateRequest) ApiCreateNvlinkLogicalPartitionRequest {
	r.nVLinkLogicalPartitionCreateRequest = &nVLinkLogicalPartitionCreateRequest
	return r
}

func (r ApiCreateNvlinkLogicalPartitionRequest) Execute() (*NVLinkLogicalPartition, *http.Response, error) {
	return r.ApiService.CreateNvlinkLogicalPartitionExecute(r)
}

/*
CreateNvlinkLogicalPartition Create NVLink Logical Partition

Create an NVLink Logical Partition for the org.

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` NGC role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the NGC Org
 @return ApiCreateNvlinkLogicalPartitionRequest
*/
func (a *NVLinkLogicalPartitionAPIService) CreateNvlinkLogicalPartition(ctx context.Context, org string) ApiCreateNvlinkLogicalPartitionRequest {
	return ApiCreateNvlinkLogicalPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return NVLinkLogicalPartition
func (a *NVLinkLogicalPartitionAPIService) CreateNvlinkLogicalPartitionExecute(r ApiCreateNvlinkLogicalPartitionRequest) (*NVLinkLogicalPartition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NVLinkLogicalPartition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NVLinkLogicalPartitionAPIService.CreateNvlinkLogicalPartition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/nvlink-logical-partition"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nVLinkLogicalPartitionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNvlinkLogicalPartitionRequest struct {
	ctx context.Context
	ApiService *NVLinkLogicalPartitionAPIService
	org string
	nvLinkLogicalPartitionId string
}

func (r ApiDeleteNvlinkLogicalPartitionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNvlinkLogicalPartitionExecute(r)
}

/*
DeleteNvlinkLogicalPartition Delete NVLink Logical Partition

Delete an NVLink Logical Partition by ID

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` NGC role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the NGC Org
 @param nvLinkLogicalPartitionId ID of the NVLink Logical Partition
 @return ApiDeleteNvlinkLogicalPartitionRequest
*/
func (a *NVLinkLogicalPartitionAPIService) DeleteNvlinkLogicalPartition(ctx context.Context, org string, nvLinkLogicalPartitionId string) ApiDeleteNvlinkLogicalPartitionRequest {
	return ApiDeleteNvlinkLogicalPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		nvLinkLogicalPartitionId: nvLinkLogicalPartitionId,
	}
}

// Execute executes the request
func (a *NVLinkLogicalPartitionAPIService) DeleteNvlinkLogicalPartitionExecute(r ApiDeleteNvlinkLogicalPartitionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NVLinkLogicalPartitionAPIService.DeleteNvlinkLogicalPartition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/nvlink-logical-partition/{nvLinkLogicalPartitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nvLinkLogicalPartitionId"+"}", url.PathEscape(parameterValueToString(r.nvLinkLogicalPartitionId, "nvLinkLogicalPartitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllNvlinkInterfaceRequest struct {
	ctx context.Context
	ApiService *NVLinkLogicalPartitionAPIService
	org string
	status *string
	siteId *string
	instanceId *string
	nvLinkLogicalPartitionId *string
	nvLinkDomainId *string
	includeRelation *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter NVLink Interfaces by Status. Can be specified multiple times to filter on more than one status.
func (r ApiGetAllNvlinkInterfaceRequest) Status(status string) ApiGetAllNvlinkInterfaceRequest {
	r.status = &status
	return r
}

// Filter NVLink Interfaces by Site ID.  Can be specified multiple times to filter on more than one ID.
func (r ApiGetAllNvlinkInterfaceRequest) SiteId(siteId string) ApiGetAllNvlinkInterfaceRequest {
	r.siteId = &siteId
	return r
}

// Filter NVLink Interfaces by Instance ID.  Can be specified multiple times to filter on more than one ID.
func (r ApiGetAllNvlinkInterfaceRequest) InstanceId(instanceId string) ApiGetAllNvlinkInterfaceRequest {
	r.instanceId = &instanceId
	return r
}

// Filter NVLink Interfaces by NVLink Logical Partition ID.  Can be specified multiple times to filter on more than one ID.
func (r ApiGetAllNvlinkInterfaceRequest) NvLinkLogicalPartitionId(nvLinkLogicalPartitionId string) ApiGetAllNvlinkInterfaceRequest {
	r.nvLinkLogicalPartitionId = &nvLinkLogicalPartitionId
	return r
}

// Filter NVLink Interfaces by NVLink Domain ID.  Can be specified multiple times to filter on more than one ID.
func (r ApiGetAllNvlinkInterfaceRequest) NvLinkDomainId(nvLinkDomainId string) ApiGetAllNvlinkInterfaceRequest {
	r.nvLinkDomainId = &nvLinkDomainId
	return r
}

// Related entity to expand
func (r ApiGetAllNvlinkInterfaceRequest) IncludeRelation(includeRelation string) ApiGetAllNvlinkInterfaceRequest {
	r.includeRelation = &includeRelation
	return r
}

// Page number for pagination query
func (r ApiGetAllNvlinkInterfaceRequest) PageNumber(pageNumber int32) ApiGetAllNvlinkInterfaceRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllNvlinkInterfaceRequest) PageSize(pageSize int32) ApiGetAllNvlinkInterfaceRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllNvlinkInterfaceRequest) OrderBy(orderBy string) ApiGetAllNvlinkInterfaceRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllNvlinkInterfaceRequest) Execute() ([]NVLinkInterface, *http.Response, error) {
	return r.ApiService.GetAllNvlinkInterfaceExecute(r)
}

/*
GetAllNvlinkInterface Retrieve all NVLink Interfaces

Get all NVLink Interfaces

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` NGC role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the NGC Org
 @return ApiGetAllNvlinkInterfaceRequest
*/
func (a *NVLinkLogicalPartitionAPIService) GetAllNvlinkInterface(ctx context.Context, org string) ApiGetAllNvlinkInterfaceRequest {
	return ApiGetAllNvlinkInterfaceRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []NVLinkInterface
func (a *NVLinkLogicalPartitionAPIService) GetAllNvlinkInterfaceExecute(r ApiGetAllNvlinkInterfaceRequest) ([]NVLinkInterface, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NVLinkInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NVLinkLogicalPartitionAPIService.GetAllNvlinkInterface")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/nvlink-interface"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceId", r.instanceId, "form", "")
	}
	if r.nvLinkLogicalPartitionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nvLinkLogicalPartitionId", r.nvLinkLogicalPartitionId, "form", "")
	}
	if r.nvLinkDomainId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nvLinkDomainId", r.nvLinkDomainId, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", defaultValue, "form", "")
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllNvlinkLogicalPartitionRequest struct {
	ctx context.Context
	ApiService *NVLinkLogicalPartitionAPIService
	org string
	siteId *string
	status *string
	query *string
	includeInterfaces *bool
	includeStats *bool
	includeVpcs *bool
	includeRelation *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter NVLink Logical Partitions by Site
func (r ApiGetAllNvlinkLogicalPartitionRequest) SiteId(siteId string) ApiGetAllNvlinkLogicalPartitionRequest {
	r.siteId = &siteId
	return r
}

// Filter NVLink Logical Partitions by Status
func (r ApiGetAllNvlinkLogicalPartitionRequest) Status(status string) ApiGetAllNvlinkLogicalPartitionRequest {
	r.status = &status
	return r
}

// Search for matches across all Sites. Input will be matched against name, description and status fields
func (r ApiGetAllNvlinkLogicalPartitionRequest) Query(query string) ApiGetAllNvlinkLogicalPartitionRequest {
	r.query = &query
	return r
}

// Include NVLink Interfaces in response.
func (r ApiGetAllNvlinkLogicalPartitionRequest) IncludeInterfaces(includeInterfaces bool) ApiGetAllNvlinkLogicalPartitionRequest {
	r.includeInterfaces = &includeInterfaces
	return r
}

// Include NVLink Logical Partition Stats in response.
func (r ApiGetAllNvlinkLogicalPartitionRequest) IncludeStats(includeStats bool) ApiGetAllNvlinkLogicalPartitionRequest {
	r.includeStats = &includeStats
	return r
}

// Include VPCs in response.
func (r ApiGetAllNvlinkLogicalPartitionRequest) IncludeVpcs(includeVpcs bool) ApiGetAllNvlinkLogicalPartitionRequest {
	r.includeVpcs = &includeVpcs
	return r
}

// Related entity to expand
func (r ApiGetAllNvlinkLogicalPartitionRequest) IncludeRelation(includeRelation string) ApiGetAllNvlinkLogicalPartitionRequest {
	r.includeRelation = &includeRelation
	return r
}

// Page number for pagination query
func (r ApiGetAllNvlinkLogicalPartitionRequest) PageNumber(pageNumber int32) ApiGetAllNvlinkLogicalPartitionRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllNvlinkLogicalPartitionRequest) PageSize(pageSize int32) ApiGetAllNvlinkLogicalPartitionRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllNvlinkLogicalPartitionRequest) OrderBy(orderBy string) ApiGetAllNvlinkLogicalPartitionRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllNvlinkLogicalPartitionRequest) Execute() ([]NVLinkLogicalPartition, *http.Response, error) {
	return r.ApiService.GetAllNvlinkLogicalPartitionExecute(r)
}

/*
GetAllNvlinkLogicalPartition Retrieve all NVLink Logical Partitions

Retrieve all NVLink Logical Partitions for the org

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the NGC Org
 @return ApiGetAllNvlinkLogicalPartitionRequest
*/
func (a *NVLinkLogicalPartitionAPIService) GetAllNvlinkLogicalPartition(ctx context.Context, org string) ApiGetAllNvlinkLogicalPartitionRequest {
	return ApiGetAllNvlinkLogicalPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []NVLinkLogicalPartition
func (a *NVLinkLogicalPartitionAPIService) GetAllNvlinkLogicalPartitionExecute(r ApiGetAllNvlinkLogicalPartitionRequest) ([]NVLinkLogicalPartition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NVLinkLogicalPartition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NVLinkLogicalPartitionAPIService.GetAllNvlinkLogicalPartition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/nvlink-logical-partition"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.includeInterfaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInterfaces", r.includeInterfaces, "form", "")
	}
	if r.includeStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeStats", r.includeStats, "form", "")
	}
	if r.includeVpcs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeVpcs", r.includeVpcs, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", defaultValue, "form", "")
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNvlinkLogicalPartitionRequest struct {
	ctx context.Context
	ApiService *NVLinkLogicalPartitionAPIService
	org string
	nvLinkLogicalPartitionId string
	includeInterfaces *string
	includeStats *bool
	includeVpcs *bool
	includeRelation *string
}

// Include all attached NVLink Interfaces in response
func (r ApiGetNvlinkLogicalPartitionRequest) IncludeInterfaces(includeInterfaces string) ApiGetNvlinkLogicalPartitionRequest {
	r.includeInterfaces = &includeInterfaces
	return r
}

// Include NVLink Logical Partition Stats in response
func (r ApiGetNvlinkLogicalPartitionRequest) IncludeStats(includeStats bool) ApiGetNvlinkLogicalPartitionRequest {
	r.includeStats = &includeStats
	return r
}

// Include all attached VPCs in response
func (r ApiGetNvlinkLogicalPartitionRequest) IncludeVpcs(includeVpcs bool) ApiGetNvlinkLogicalPartitionRequest {
	r.includeVpcs = &includeVpcs
	return r
}

// Related entity to expand
func (r ApiGetNvlinkLogicalPartitionRequest) IncludeRelation(includeRelation string) ApiGetNvlinkLogicalPartitionRequest {
	r.includeRelation = &includeRelation
	return r
}

func (r ApiGetNvlinkLogicalPartitionRequest) Execute() (*NVLinkLogicalPartition, *http.Response, error) {
	return r.ApiService.GetNvlinkLogicalPartitionExecute(r)
}

/*
GetNvlinkLogicalPartition Retrieve NVLink Logical Partition

Retrieve a specific NVLink Logical Partition by ID

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` NGC role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the NGC Org
 @param nvLinkLogicalPartitionId ID of the NVLink Logical Partition
 @return ApiGetNvlinkLogicalPartitionRequest
*/
func (a *NVLinkLogicalPartitionAPIService) GetNvlinkLogicalPartition(ctx context.Context, org string, nvLinkLogicalPartitionId string) ApiGetNvlinkLogicalPartitionRequest {
	return ApiGetNvlinkLogicalPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		nvLinkLogicalPartitionId: nvLinkLogicalPartitionId,
	}
}

// Execute executes the request
//  @return NVLinkLogicalPartition
func (a *NVLinkLogicalPartitionAPIService) GetNvlinkLogicalPartitionExecute(r ApiGetNvlinkLogicalPartitionRequest) (*NVLinkLogicalPartition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NVLinkLogicalPartition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NVLinkLogicalPartitionAPIService.GetNvlinkLogicalPartition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/nvlink-logical-partition/{nvLinkLogicalPartitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nvLinkLogicalPartitionId"+"}", url.PathEscape(parameterValueToString(r.nvLinkLogicalPartitionId, "nvLinkLogicalPartitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeInterfaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInterfaces", r.includeInterfaces, "form", "")
	}
	if r.includeStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeStats", r.includeStats, "form", "")
	}
	if r.includeVpcs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeVpcs", r.includeVpcs, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNvlinkLogicalPartitionRequest struct {
	ctx context.Context
	ApiService *NVLinkLogicalPartitionAPIService
	org string
	nvLinkLogicalPartitionId string
	nVLinkLogicalPartitionUpdateRequest *NVLinkLogicalPartitionUpdateRequest
}

func (r ApiUpdateNvlinkLogicalPartitionRequest) NVLinkLogicalPartitionUpdateRequest(nVLinkLogicalPartitionUpdateRequest NVLinkLogicalPartitionUpdateRequest) ApiUpdateNvlinkLogicalPartitionRequest {
	r.nVLinkLogicalPartitionUpdateRequest = &nVLinkLogicalPartitionUpdateRequest
	return r
}

func (r ApiUpdateNvlinkLogicalPartitionRequest) Execute() (*NVLinkLogicalPartition, *http.Response, error) {
	return r.ApiService.UpdateNvlinkLogicalPartitionExecute(r)
}

/*
UpdateNvlinkLogicalPartition Update NVLink Logical Partition

Update a specific NVLink Logical Partition

Org must have a Tenant entity. User must have `FORGE_TENANT_ADMIN` NGC role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the NGC Org
 @param nvLinkLogicalPartitionId ID of the NVLink Logical Partition
 @return ApiUpdateNvlinkLogicalPartitionRequest
*/
func (a *NVLinkLogicalPartitionAPIService) UpdateNvlinkLogicalPartition(ctx context.Context, org string, nvLinkLogicalPartitionId string) ApiUpdateNvlinkLogicalPartitionRequest {
	return ApiUpdateNvlinkLogicalPartitionRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		nvLinkLogicalPartitionId: nvLinkLogicalPartitionId,
	}
}

// Execute executes the request
//  @return NVLinkLogicalPartition
func (a *NVLinkLogicalPartitionAPIService) UpdateNvlinkLogicalPartitionExecute(r ApiUpdateNvlinkLogicalPartitionRequest) (*NVLinkLogicalPartition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NVLinkLogicalPartition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NVLinkLogicalPartitionAPIService.UpdateNvlinkLogicalPartition")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/nvlink-logical-partition/{nvLinkLogicalPartitionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nvLinkLogicalPartitionId"+"}", url.PathEscape(parameterValueToString(r.nvLinkLogicalPartitionId, "nvLinkLogicalPartitionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nVLinkLogicalPartitionUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
