/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InstanceTypeAPIService InstanceTypeAPI service
type InstanceTypeAPIService service

type ApiCreateInstanceTypeRequest struct {
	ctx context.Context
	ApiService *InstanceTypeAPIService
	org string
	instanceTypeCreateRequest *InstanceTypeCreateRequest
}

func (r ApiCreateInstanceTypeRequest) InstanceTypeCreateRequest(instanceTypeCreateRequest InstanceTypeCreateRequest) ApiCreateInstanceTypeRequest {
	r.instanceTypeCreateRequest = &instanceTypeCreateRequest
	return r
}

func (r ApiCreateInstanceTypeRequest) Execute() (*InstanceType, *http.Response, error) {
	return r.ApiService.CreateInstanceTypeExecute(r)
}

/*
CreateInstanceType Create an Instance Type

Create an Instance Type for Infrastructure Provider.

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` authorization role.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiCreateInstanceTypeRequest
*/
func (a *InstanceTypeAPIService) CreateInstanceType(ctx context.Context, org string) ApiCreateInstanceTypeRequest {
	return ApiCreateInstanceTypeRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return InstanceType
func (a *InstanceTypeAPIService) CreateInstanceTypeExecute(r ApiCreateInstanceTypeRequest) (*InstanceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceTypeAPIService.CreateInstanceType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/instance/type"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.instanceTypeCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInstanceTypeMachineAssociationRequest struct {
	ctx context.Context
	ApiService *InstanceTypeAPIService
	org string
	instanceTypeId string
	machineInstanceTypeCreateRequest *MachineInstanceTypeCreateRequest
}

func (r ApiCreateInstanceTypeMachineAssociationRequest) MachineInstanceTypeCreateRequest(machineInstanceTypeCreateRequest MachineInstanceTypeCreateRequest) ApiCreateInstanceTypeMachineAssociationRequest {
	r.machineInstanceTypeCreateRequest = &machineInstanceTypeCreateRequest
	return r
}

func (r ApiCreateInstanceTypeMachineAssociationRequest) Execute() ([]MachineInstanceType, *http.Response, error) {
	return r.ApiService.CreateInstanceTypeMachineAssociationExecute(r)
}

/*
CreateInstanceTypeMachineAssociation Create a Machine/Instance Type association

Associate a Machine to an Instance Type

Org must have an Infrastructure Provider entity that owns the Instance Type and the Machine. User must have `FORGE_PROVIDER_ADMIN` authorization role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param instanceTypeId ID of the Instance Type
 @return ApiCreateInstanceTypeMachineAssociationRequest
*/
func (a *InstanceTypeAPIService) CreateInstanceTypeMachineAssociation(ctx context.Context, org string, instanceTypeId string) ApiCreateInstanceTypeMachineAssociationRequest {
	return ApiCreateInstanceTypeMachineAssociationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		instanceTypeId: instanceTypeId,
	}
}

// Execute executes the request
//  @return []MachineInstanceType
func (a *InstanceTypeAPIService) CreateInstanceTypeMachineAssociationExecute(r ApiCreateInstanceTypeMachineAssociationRequest) ([]MachineInstanceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MachineInstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceTypeAPIService.CreateInstanceTypeMachineAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/instance/type/{instanceTypeId}/machine"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceTypeId"+"}", url.PathEscape(parameterValueToString(r.instanceTypeId, "instanceTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.machineInstanceTypeCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteInstanceTypeRequest struct {
	ctx context.Context
	ApiService *InstanceTypeAPIService
	org string
	instanceTypeId string
}

func (r ApiDeleteInstanceTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteInstanceTypeExecute(r)
}

/*
DeleteInstanceType Delete Instance Type

Delete an Instance Type by ID.

Org must have an Infrastructure Provider entity that owns the Instance Type. User must have `FORGE_PROVIDER_ADMIN` authorization role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param instanceTypeId ID of the Instance Type
 @return ApiDeleteInstanceTypeRequest
*/
func (a *InstanceTypeAPIService) DeleteInstanceType(ctx context.Context, org string, instanceTypeId string) ApiDeleteInstanceTypeRequest {
	return ApiDeleteInstanceTypeRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		instanceTypeId: instanceTypeId,
	}
}

// Execute executes the request
func (a *InstanceTypeAPIService) DeleteInstanceTypeExecute(r ApiDeleteInstanceTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceTypeAPIService.DeleteInstanceType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/instance/type/{instanceTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceTypeId"+"}", url.PathEscape(parameterValueToString(r.instanceTypeId, "instanceTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteInstanceTypeMachineAssociationRequest struct {
	ctx context.Context
	ApiService *InstanceTypeAPIService
	org string
	instanceTypeId string
	machineAssociationId string
}

func (r ApiDeleteInstanceTypeMachineAssociationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteInstanceTypeMachineAssociationExecute(r)
}

/*
DeleteInstanceTypeMachineAssociation Delete a Machine/Instance Type association

Delete a Machine's association with an Instance Type

Org must have an Infrastructure Provider entity that owns the Instance Type and the Machine. User must have `FORGE_PROVIDER_ADMIN` authorization role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param instanceTypeId ID of the Instance Type
 @param machineAssociationId ID of the Machine/Instance Type Association
 @return ApiDeleteInstanceTypeMachineAssociationRequest
*/
func (a *InstanceTypeAPIService) DeleteInstanceTypeMachineAssociation(ctx context.Context, org string, instanceTypeId string, machineAssociationId string) ApiDeleteInstanceTypeMachineAssociationRequest {
	return ApiDeleteInstanceTypeMachineAssociationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		instanceTypeId: instanceTypeId,
		machineAssociationId: machineAssociationId,
	}
}

// Execute executes the request
func (a *InstanceTypeAPIService) DeleteInstanceTypeMachineAssociationExecute(r ApiDeleteInstanceTypeMachineAssociationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceTypeAPIService.DeleteInstanceTypeMachineAssociation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/instance/type/{instanceTypeId}/machine/{machineAssociationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceTypeId"+"}", url.PathEscape(parameterValueToString(r.instanceTypeId, "instanceTypeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"machineAssociationId"+"}", url.PathEscape(parameterValueToString(r.machineAssociationId, "machineAssociationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllInstanceTypeRequest struct {
	ctx context.Context
	ApiService *InstanceTypeAPIService
	siteId *string
	org string
	infrastructureProviderId *string
	tenantId *string
	status *string
	query *string
	includeRelation *string
	includeMachineAssignment *bool
	includeAllocationStats *bool
	excludeUnallocated *bool
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter Instance Types by Site ID
func (r ApiGetAllInstanceTypeRequest) SiteId(siteId string) ApiGetAllInstanceTypeRequest {
	r.siteId = &siteId
	return r
}

// Filter Instance Types by Infrastructure Provider ID
func (r ApiGetAllInstanceTypeRequest) InfrastructureProviderId(infrastructureProviderId string) ApiGetAllInstanceTypeRequest {
	r.infrastructureProviderId = &infrastructureProviderId
	return r
}

// Filter Instance Types by Tenant ID
func (r ApiGetAllInstanceTypeRequest) TenantId(tenantId string) ApiGetAllInstanceTypeRequest {
	r.tenantId = &tenantId
	return r
}

// Filter Instance Types by Status
func (r ApiGetAllInstanceTypeRequest) Status(status string) ApiGetAllInstanceTypeRequest {
	r.status = &status
	return r
}

// Search for matches across all Sites. Input will be matched against name, display name, description, labels and status fields
func (r ApiGetAllInstanceTypeRequest) Query(query string) ApiGetAllInstanceTypeRequest {
	r.query = &query
	return r
}

// Related entity to expand
func (r ApiGetAllInstanceTypeRequest) IncludeRelation(includeRelation string) ApiGetAllInstanceTypeRequest {
	r.includeRelation = &includeRelation
	return r
}

// Include Machine assignments for each Instance Type. Can only be requested by Provider.
func (r ApiGetAllInstanceTypeRequest) IncludeMachineAssignment(includeMachineAssignment bool) ApiGetAllInstanceTypeRequest {
	r.includeMachineAssignment = &includeMachineAssignment
	return r
}

// Include Allocation stats. Currently can only be requested by Tenant
func (r ApiGetAllInstanceTypeRequest) IncludeAllocationStats(includeAllocationStats bool) ApiGetAllInstanceTypeRequest {
	r.includeAllocationStats = &includeAllocationStats
	return r
}

// Excludes InstanceType records that have no allocations from being returned in the result set. Currently can only be requested by Tenant.
func (r ApiGetAllInstanceTypeRequest) ExcludeUnallocated(excludeUnallocated bool) ApiGetAllInstanceTypeRequest {
	r.excludeUnallocated = &excludeUnallocated
	return r
}

// Page number for pagination query
func (r ApiGetAllInstanceTypeRequest) PageNumber(pageNumber int32) ApiGetAllInstanceTypeRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllInstanceTypeRequest) PageSize(pageSize int32) ApiGetAllInstanceTypeRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllInstanceTypeRequest) OrderBy(orderBy string) ApiGetAllInstanceTypeRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllInstanceTypeRequest) Execute() ([]InstanceType, *http.Response, error) {
	return r.ApiService.GetAllInstanceTypeExecute(r)
}

/*
GetAllInstanceType Retrieve all Instance Types

Get all Instance Types.

`siteId` query param must be specified. Either `infrastructureProviderId` or `tenantId` query param must be specified.

If `infrastructureProviderId` query param is provided, then org must have an Infrastructure Provider entity that owns the Site specified by `siteId` in query param. User must have `FORGE_PROVIDER_ADMIN` role.

If `tenantId` query param is provided, then org must have a Tenant entity and it should have at least one Allocation with the Site specified by `siteId` in query param. User must have `FORGE_TENANT_ADMIN` role.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllInstanceTypeRequest
*/
func (a *InstanceTypeAPIService) GetAllInstanceType(ctx context.Context, org string) ApiGetAllInstanceTypeRequest {
	return ApiGetAllInstanceTypeRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []InstanceType
func (a *InstanceTypeAPIService) GetAllInstanceTypeExecute(r ApiGetAllInstanceTypeRequest) ([]InstanceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceTypeAPIService.GetAllInstanceType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/instance/type"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	if r.infrastructureProviderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "infrastructureProviderId", r.infrastructureProviderId, "form", "")
	}
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.includeMachineAssignment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMachineAssignment", r.includeMachineAssignment, "form", "")
	}
	if r.includeAllocationStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAllocationStats", r.includeAllocationStats, "form", "")
	}
	if r.excludeUnallocated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeUnallocated", r.excludeUnallocated, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", defaultValue, "form", "")
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInstanceTypeRequest struct {
	ctx context.Context
	ApiService *InstanceTypeAPIService
	org string
	instanceTypeId string
	includeMachineAssociation *bool
	includeAllocationStats *bool
	includeRelation *string
}

// Include Machine associations for each Instance Type. Can only be requested by Provider
func (r ApiGetInstanceTypeRequest) IncludeMachineAssociation(includeMachineAssociation bool) ApiGetInstanceTypeRequest {
	r.includeMachineAssociation = &includeMachineAssociation
	return r
}

// Include Allocation stats. Currently can only be requested by Tenant
func (r ApiGetInstanceTypeRequest) IncludeAllocationStats(includeAllocationStats bool) ApiGetInstanceTypeRequest {
	r.includeAllocationStats = &includeAllocationStats
	return r
}

// Related entity to expand
func (r ApiGetInstanceTypeRequest) IncludeRelation(includeRelation string) ApiGetInstanceTypeRequest {
	r.includeRelation = &includeRelation
	return r
}

func (r ApiGetInstanceTypeRequest) Execute() (*InstanceType, *http.Response, error) {
	return r.ApiService.GetInstanceTypeExecute(r)
}

/*
GetInstanceType Retrieve an Instance Type

Get an Instance Type by ID.

If the org has an Infrastructure Provider entity that owns the Instance Type, then the Instance Type detail is returned. User must have `FORGE_PROVIDER_ADMIN` role.

If the org has a Tenant entity and it has a Tenant Account with the Infrastructure Provider of the Instance Type, then the Instance Type detail is returned. User must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param instanceTypeId ID of the Instance Type
 @return ApiGetInstanceTypeRequest
*/
func (a *InstanceTypeAPIService) GetInstanceType(ctx context.Context, org string, instanceTypeId string) ApiGetInstanceTypeRequest {
	return ApiGetInstanceTypeRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		instanceTypeId: instanceTypeId,
	}
}

// Execute executes the request
//  @return InstanceType
func (a *InstanceTypeAPIService) GetInstanceTypeExecute(r ApiGetInstanceTypeRequest) (*InstanceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceTypeAPIService.GetInstanceType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/instance/type/{instanceTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceTypeId"+"}", url.PathEscape(parameterValueToString(r.instanceTypeId, "instanceTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeMachineAssociation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMachineAssociation", r.includeMachineAssociation, "form", "")
	}
	if r.includeAllocationStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAllocationStats", r.includeAllocationStats, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInstanceTypeMachineAssociationRequest struct {
	ctx context.Context
	ApiService *InstanceTypeAPIService
	org string
	instanceTypeId string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Page number for pagination query
func (r ApiGetInstanceTypeMachineAssociationRequest) PageNumber(pageNumber int32) ApiGetInstanceTypeMachineAssociationRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetInstanceTypeMachineAssociationRequest) PageSize(pageSize int32) ApiGetInstanceTypeMachineAssociationRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetInstanceTypeMachineAssociationRequest) OrderBy(orderBy string) ApiGetInstanceTypeMachineAssociationRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetInstanceTypeMachineAssociationRequest) Execute() ([]MachineInstanceType, *http.Response, error) {
	return r.ApiService.GetInstanceTypeMachineAssociationExecute(r)
}

/*
GetInstanceTypeMachineAssociation Retrieve all Machines/Instance Type associations

Get all Machines for a given Instance Type

Org must have an Infrastructure Provider entity that owns the Instance Type and the Machine. User must have `FORGE_PROVIDER_ADMIN` authorization role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param instanceTypeId ID of the Instance Type
 @return ApiGetInstanceTypeMachineAssociationRequest
*/
func (a *InstanceTypeAPIService) GetInstanceTypeMachineAssociation(ctx context.Context, org string, instanceTypeId string) ApiGetInstanceTypeMachineAssociationRequest {
	return ApiGetInstanceTypeMachineAssociationRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		instanceTypeId: instanceTypeId,
	}
}

// Execute executes the request
//  @return []MachineInstanceType
func (a *InstanceTypeAPIService) GetInstanceTypeMachineAssociationExecute(r ApiGetInstanceTypeMachineAssociationRequest) ([]MachineInstanceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MachineInstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceTypeAPIService.GetInstanceTypeMachineAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/instance/type/{instanceTypeId}/machine"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceTypeId"+"}", url.PathEscape(parameterValueToString(r.instanceTypeId, "instanceTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", defaultValue, "form", "")
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInstanceTypeRequest struct {
	ctx context.Context
	ApiService *InstanceTypeAPIService
	org string
	instanceTypeId string
	instanceTypeUpdateRequest *InstanceTypeUpdateRequest
}

// 
func (r ApiUpdateInstanceTypeRequest) InstanceTypeUpdateRequest(instanceTypeUpdateRequest InstanceTypeUpdateRequest) ApiUpdateInstanceTypeRequest {
	r.instanceTypeUpdateRequest = &instanceTypeUpdateRequest
	return r
}

func (r ApiUpdateInstanceTypeRequest) Execute() (*InstanceType, *http.Response, error) {
	return r.ApiService.UpdateInstanceTypeExecute(r)
}

/*
UpdateInstanceType Update Instance Type

Update an Instance Type by ID.

Org must have an Infrastructure Provider entity that owns the Instance Type. User must have `FORGE_PROVIDER_ADMIN` authorization role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param instanceTypeId ID of the Instance Type
 @return ApiUpdateInstanceTypeRequest
*/
func (a *InstanceTypeAPIService) UpdateInstanceType(ctx context.Context, org string, instanceTypeId string) ApiUpdateInstanceTypeRequest {
	return ApiUpdateInstanceTypeRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		instanceTypeId: instanceTypeId,
	}
}

// Execute executes the request
//  @return InstanceType
func (a *InstanceTypeAPIService) UpdateInstanceTypeExecute(r ApiUpdateInstanceTypeRequest) (*InstanceType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InstanceType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstanceTypeAPIService.UpdateInstanceType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/instance/type/{instanceTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceTypeId"+"}", url.PathEscape(parameterValueToString(r.instanceTypeId, "instanceTypeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.instanceTypeUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
