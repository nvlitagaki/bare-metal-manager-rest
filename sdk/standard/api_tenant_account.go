/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TenantAccountAPIService TenantAccountAPI service
type TenantAccountAPIService service

type ApiCreateTenantAccountRequest struct {
	ctx context.Context
	ApiService *TenantAccountAPIService
	org string
	tenantAccountCreateRequest *TenantAccountCreateRequest
}

func (r ApiCreateTenantAccountRequest) TenantAccountCreateRequest(tenantAccountCreateRequest TenantAccountCreateRequest) ApiCreateTenantAccountRequest {
	r.tenantAccountCreateRequest = &tenantAccountCreateRequest
	return r
}

func (r ApiCreateTenantAccountRequest) Execute() (*TenantAccount, *http.Response, error) {
	return r.ApiService.CreateTenantAccountExecute(r)
}

/*
CreateTenantAccount Create Tenant Account

Create a Tenant Account.

Org must have an Infrastructure Provider entity and its ID must match the Infrastructure Provider ID in request data. User must have `FORGE_PROVIDER_ADMIN` authorization role

Infrastructure Provider can create a Tenant Account by specifying the Tenant's UUID or Tenant's org name. This will set the status of the Tenant Account to "Invited". Then the Tenant can view this account information and are able to confirm/accept the account by updating the Tenant Account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiCreateTenantAccountRequest
*/
func (a *TenantAccountAPIService) CreateTenantAccount(ctx context.Context, org string) ApiCreateTenantAccountRequest {
	return ApiCreateTenantAccountRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return TenantAccount
func (a *TenantAccountAPIService) CreateTenantAccountExecute(r ApiCreateTenantAccountRequest) (*TenantAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAccountAPIService.CreateTenantAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/tenant/account"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tenantAccountCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTenantAccountRequest struct {
	ctx context.Context
	ApiService *TenantAccountAPIService
	org string
	accountId string
}

func (r ApiDeleteTenantAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTenantAccountExecute(r)
}

/*
DeleteTenantAccount Delete Tenant Account

Delete a Tenant Account by ID.

Org must have an Infrastructure Provider entity, specified Tenant Account must be created by said Provider. Requesting user must have `FORGE_PROVIDER_ADMIN` role.

Tenant cannot delete a Tenant Account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param accountId ID of the Tenant Account
 @return ApiDeleteTenantAccountRequest
*/
func (a *TenantAccountAPIService) DeleteTenantAccount(ctx context.Context, org string, accountId string) ApiDeleteTenantAccountRequest {
	return ApiDeleteTenantAccountRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		accountId: accountId,
	}
}

// Execute executes the request
func (a *TenantAccountAPIService) DeleteTenantAccountExecute(r ApiDeleteTenantAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAccountAPIService.DeleteTenantAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/tenant/account/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllTenantAccountRequest struct {
	ctx context.Context
	ApiService *TenantAccountAPIService
	org string
	infrastructureProviderId *string
	tenantId *string
	includeRelation *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter TenantAccounts by Infrastructure Provider ID
func (r ApiGetAllTenantAccountRequest) InfrastructureProviderId(infrastructureProviderId string) ApiGetAllTenantAccountRequest {
	r.infrastructureProviderId = &infrastructureProviderId
	return r
}

// Filter TenantAccounts by Tenant ID
func (r ApiGetAllTenantAccountRequest) TenantId(tenantId string) ApiGetAllTenantAccountRequest {
	r.tenantId = &tenantId
	return r
}

// Related entity to expand
func (r ApiGetAllTenantAccountRequest) IncludeRelation(includeRelation string) ApiGetAllTenantAccountRequest {
	r.includeRelation = &includeRelation
	return r
}

// Page number for pagination query
func (r ApiGetAllTenantAccountRequest) PageNumber(pageNumber int32) ApiGetAllTenantAccountRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllTenantAccountRequest) PageSize(pageSize int32) ApiGetAllTenantAccountRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllTenantAccountRequest) OrderBy(orderBy string) ApiGetAllTenantAccountRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllTenantAccountRequest) Execute() ([]TenantAccount, *http.Response, error) {
	return r.ApiService.GetAllTenantAccountExecute(r)
}

/*
GetAllTenantAccount Retrieve all Tenant Accounts

Retrieve all Tenant Accounts.

Either `infrastructureProviderId` or `tenantId` query param must be specified.

If `infrastructureProviderId` query param is provided, then org must have an Infrastructure Provider entity and its ID should match the query param value. User must have `FORGE_PROVIDER_ADMIN` role.

If `tenantId` query param is provided, then org must have a Tenant entity and its ID should match the query param value. User must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllTenantAccountRequest
*/
func (a *TenantAccountAPIService) GetAllTenantAccount(ctx context.Context, org string) ApiGetAllTenantAccountRequest {
	return ApiGetAllTenantAccountRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []TenantAccount
func (a *TenantAccountAPIService) GetAllTenantAccountExecute(r ApiGetAllTenantAccountRequest) ([]TenantAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TenantAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAccountAPIService.GetAllTenantAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/tenant/account"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.infrastructureProviderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "infrastructureProviderId", r.infrastructureProviderId, "form", "")
	}
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTenantAccountRequest struct {
	ctx context.Context
	ApiService *TenantAccountAPIService
	org string
	accountId string
	infrastructureProviderId *string
	tenantId *string
	includeRelation *string
}

// Filter Tenant Accounts by Infrastructure Provider ID
func (r ApiGetTenantAccountRequest) InfrastructureProviderId(infrastructureProviderId string) ApiGetTenantAccountRequest {
	r.infrastructureProviderId = &infrastructureProviderId
	return r
}

// Filter Tenant Accounts by Tenant ID
func (r ApiGetTenantAccountRequest) TenantId(tenantId string) ApiGetTenantAccountRequest {
	r.tenantId = &tenantId
	return r
}

// Related entity to expand
func (r ApiGetTenantAccountRequest) IncludeRelation(includeRelation string) ApiGetTenantAccountRequest {
	r.includeRelation = &includeRelation
	return r
}

func (r ApiGetTenantAccountRequest) Execute() (*TenantAccount, *http.Response, error) {
	return r.ApiService.GetTenantAccountExecute(r)
}

/*
GetTenantAccount Retrieve Tenant Account

Retrieve a Tenant Account by ID

Either `infrastructureProviderId` or `tenantId` query param must be specified.

If `infrastructureProviderId` query param is provided, then org must have an Infrastructure Provider entity and its ID should match the query param value. User must have `FORGE_PROVIDER_ADMIN` role.

If `tenantId` query param is provided, then org must have a Tenant entity and its ID should match the query param value. User must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param accountId ID of the Tenant Account
 @return ApiGetTenantAccountRequest
*/
func (a *TenantAccountAPIService) GetTenantAccount(ctx context.Context, org string, accountId string) ApiGetTenantAccountRequest {
	return ApiGetTenantAccountRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return TenantAccount
func (a *TenantAccountAPIService) GetTenantAccountExecute(r ApiGetTenantAccountRequest) (*TenantAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAccountAPIService.GetTenantAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/tenant/account/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.infrastructureProviderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "infrastructureProviderId", r.infrastructureProviderId, "form", "")
	}
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTenantAccountRequest struct {
	ctx context.Context
	ApiService *TenantAccountAPIService
	org string
	accountId string
	body *map[string]interface{}
}

// No params needed, an empty request body will suffice.
func (r ApiUpdateTenantAccountRequest) Body(body map[string]interface{}) ApiUpdateTenantAccountRequest {
	r.body = &body
	return r
}

func (r ApiUpdateTenantAccountRequest) Execute() (*TenantAccount, *http.Response, error) {
	return r.ApiService.UpdateTenantAccountExecute(r)
}

/*
UpdateTenantAccount Update Tenant Account

Update a Tenant Account.

Can be used to accept an invitation sent by Infrastructure Provider.

Org must have a tenant entity whose ID matches the `tenantId` of the Tenant Account object. User must have `FORGE_TENANT_ADMIN` role. Can only update a TenantAccount that has `Invited` status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param accountId ID of the Tenant Account
 @return ApiUpdateTenantAccountRequest
*/
func (a *TenantAccountAPIService) UpdateTenantAccount(ctx context.Context, org string, accountId string) ApiUpdateTenantAccountRequest {
	return ApiUpdateTenantAccountRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return TenantAccount
func (a *TenantAccountAPIService) UpdateTenantAccountExecute(r ApiUpdateTenantAccountRequest) (*TenantAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TenantAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TenantAccountAPIService.UpdateTenantAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/tenant/account/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
