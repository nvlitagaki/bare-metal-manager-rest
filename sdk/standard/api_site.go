/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SiteAPIService SiteAPI service
type SiteAPIService service

type ApiCreateSiteRequest struct {
	ctx context.Context
	ApiService *SiteAPIService
	org string
	siteCreateRequest *SiteCreateRequest
}

func (r ApiCreateSiteRequest) SiteCreateRequest(siteCreateRequest SiteCreateRequest) ApiCreateSiteRequest {
	r.siteCreateRequest = &siteCreateRequest
	return r
}

func (r ApiCreateSiteRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.CreateSiteExecute(r)
}

/*
CreateSite Create Site

Create a Site for the org.

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` authorization role.

Tenant cannot create a Site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiCreateSiteRequest
*/
func (a *SiteAPIService) CreateSite(ctx context.Context, org string) ApiCreateSiteRequest {
	return ApiCreateSiteRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return Site
func (a *SiteAPIService) CreateSiteExecute(r ApiCreateSiteRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SiteAPIService.CreateSite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/site"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.siteCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSiteRequest struct {
	ctx context.Context
	ApiService *SiteAPIService
	org string
	siteId string
	purgeMachines *bool
}

// Scrub all Machine data associated with this Site to re-pair
func (r ApiDeleteSiteRequest) PurgeMachines(purgeMachines bool) ApiDeleteSiteRequest {
	r.purgeMachines = &purgeMachines
	return r
}

func (r ApiDeleteSiteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSiteExecute(r)
}

/*
DeleteSite Delete Site

Delete a specific Site

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` authorization role.

Site can only be deleted if all Allocations have been deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param siteId ID of the Site
 @return ApiDeleteSiteRequest
*/
func (a *SiteAPIService) DeleteSite(ctx context.Context, org string, siteId string) ApiDeleteSiteRequest {
	return ApiDeleteSiteRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		siteId: siteId,
	}
}

// Execute executes the request
func (a *SiteAPIService) DeleteSiteExecute(r ApiDeleteSiteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SiteAPIService.DeleteSite")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/site/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purgeMachines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purgeMachines", r.purgeMachines, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllSiteRequest struct {
	ctx context.Context
	ApiService *SiteAPIService
	org string
	infrastructureProviderId *string
	tenantId *string
	status *string
	isNativeNetworkingEnabled *bool
	isNetworkSecurityGroupEnabled *bool
	isNVLinkPartitionEnabled *bool
	includeMachineStats *bool
	query *string
	includeRelation *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter Sites by Infrastructure Provider ID
func (r ApiGetAllSiteRequest) InfrastructureProviderId(infrastructureProviderId string) ApiGetAllSiteRequest {
	r.infrastructureProviderId = &infrastructureProviderId
	return r
}

// Filter Sites by Tenant ID
func (r ApiGetAllSiteRequest) TenantId(tenantId string) ApiGetAllSiteRequest {
	r.tenantId = &tenantId
	return r
}

// Filter Sites by Status. Can be specified multiple times to filter on more than one status
func (r ApiGetAllSiteRequest) Status(status string) ApiGetAllSiteRequest {
	r.status = &status
	return r
}

// Filter Sites by native networking enabled flag. Requires Provider Admin role.
func (r ApiGetAllSiteRequest) IsNativeNetworkingEnabled(isNativeNetworkingEnabled bool) ApiGetAllSiteRequest {
	r.isNativeNetworkingEnabled = &isNativeNetworkingEnabled
	return r
}

// Filter Sites by network security group enabled flag. Requires Provider Admin role.
func (r ApiGetAllSiteRequest) IsNetworkSecurityGroupEnabled(isNetworkSecurityGroupEnabled bool) ApiGetAllSiteRequest {
	r.isNetworkSecurityGroupEnabled = &isNetworkSecurityGroupEnabled
	return r
}

// Filter Sites by NVLink partitioning enabled flag. Requires Provider Admin role.
func (r ApiGetAllSiteRequest) IsNVLinkPartitionEnabled(isNVLinkPartitionEnabled bool) ApiGetAllSiteRequest {
	r.isNVLinkPartitionEnabled = &isNVLinkPartitionEnabled
	return r
}

// Include a breakdown of Machine counts by life-cycle status and health. Requires Provider Admin role.
func (r ApiGetAllSiteRequest) IncludeMachineStats(includeMachineStats bool) ApiGetAllSiteRequest {
	r.includeMachineStats = &includeMachineStats
	return r
}

// Search for matches across all Sites. Input will be matched against name, description, location, contact, and status fields
func (r ApiGetAllSiteRequest) Query(query string) ApiGetAllSiteRequest {
	r.query = &query
	return r
}

// Related entity to expand
func (r ApiGetAllSiteRequest) IncludeRelation(includeRelation string) ApiGetAllSiteRequest {
	r.includeRelation = &includeRelation
	return r
}

// Page number for pagination query
func (r ApiGetAllSiteRequest) PageNumber(pageNumber int32) ApiGetAllSiteRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllSiteRequest) PageSize(pageSize int32) ApiGetAllSiteRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllSiteRequest) OrderBy(orderBy string) ApiGetAllSiteRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllSiteRequest) Execute() ([]Site, *http.Response, error) {
	return r.ApiService.GetAllSiteExecute(r)
}

/*
GetAllSite Retrieve all Sites

Retrieve all Sites for org.

User must have `FORGE_PROVIDER_ADMIN` or `FORGE_TENANT_ADMIN` role. `infrastructureProviderId` or `tenantId` query param may be required for older API versions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllSiteRequest
*/
func (a *SiteAPIService) GetAllSite(ctx context.Context, org string) ApiGetAllSiteRequest {
	return ApiGetAllSiteRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []Site
func (a *SiteAPIService) GetAllSiteExecute(r ApiGetAllSiteRequest) ([]Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SiteAPIService.GetAllSite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/site"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.infrastructureProviderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "infrastructureProviderId", r.infrastructureProviderId, "form", "")
	}
	if r.tenantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantId", r.tenantId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.isNativeNetworkingEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNativeNetworkingEnabled", r.isNativeNetworkingEnabled, "form", "")
	}
	if r.isNetworkSecurityGroupEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNetworkSecurityGroupEnabled", r.isNetworkSecurityGroupEnabled, "form", "")
	}
	if r.isNVLinkPartitionEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNVLinkPartitionEnabled", r.isNVLinkPartitionEnabled, "form", "")
	}
	if r.includeMachineStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeMachineStats", r.includeMachineStats, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteRequest struct {
	ctx context.Context
	ApiService *SiteAPIService
	org string
	siteId string
}

func (r ApiGetSiteRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.GetSiteExecute(r)
}

/*
GetSite Retrieve Site

Retrieve a specific Site by ID.

User must have `FORGE_PROVIDER_ADMIN` or `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param siteId ID of the Site
 @return ApiGetSiteRequest
*/
func (a *SiteAPIService) GetSite(ctx context.Context, org string, siteId string) ApiGetSiteRequest {
	return ApiGetSiteRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return Site
func (a *SiteAPIService) GetSiteExecute(r ApiGetSiteRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SiteAPIService.GetSite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/site/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteStatusHistoryRequest struct {
	ctx context.Context
	ApiService *SiteAPIService
	org string
	siteId string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Page number for pagination query
func (r ApiGetSiteStatusHistoryRequest) PageNumber(pageNumber int32) ApiGetSiteStatusHistoryRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetSiteStatusHistoryRequest) PageSize(pageSize int32) ApiGetSiteStatusHistoryRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetSiteStatusHistoryRequest) OrderBy(orderBy string) ApiGetSiteStatusHistoryRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetSiteStatusHistoryRequest) Execute() ([]StatusDetail, *http.Response, error) {
	return r.ApiService.GetSiteStatusHistoryExecute(r)
}

/*
GetSiteStatusHistory Retrieve Site status history

Retrieve a specific Site status history

Either `infrastructureProviderId` or `tenantId` query param must be specified.

If `infrastructureProviderId` query param is provided, then org must have an Infrastructure Provider entity and its ID should match the query param value. User must have `FORGE_PROVIDER_ADMIN` role. The Infrastructure Provider must own the Site.

If `tenantId` query param is provided, then org must have a Tenant entity and its ID should match the query param value. User must have `FORGE_TENANT_ADMIN` role. The Tenant must have an allocation with the Site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param siteId ID of the Site
 @return ApiGetSiteStatusHistoryRequest
*/
func (a *SiteAPIService) GetSiteStatusHistory(ctx context.Context, org string, siteId string) ApiGetSiteStatusHistoryRequest {
	return ApiGetSiteStatusHistoryRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return []StatusDetail
func (a *SiteAPIService) GetSiteStatusHistoryExecute(r ApiGetSiteStatusHistoryRequest) ([]StatusDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StatusDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SiteAPIService.GetSiteStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/site/{siteId}/status-history"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSiteRequest struct {
	ctx context.Context
	ApiService *SiteAPIService
	org string
	siteId string
	siteUpdateRequest *SiteUpdateRequest
}

func (r ApiUpdateSiteRequest) SiteUpdateRequest(siteUpdateRequest SiteUpdateRequest) ApiUpdateSiteRequest {
	r.siteUpdateRequest = &siteUpdateRequest
	return r
}

func (r ApiUpdateSiteRequest) Execute() (*Site, *http.Response, error) {
	return r.ApiService.UpdateSiteExecute(r)
}

/*
UpdateSite Update Site

Update a specific Site

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` or `FORGE_TENANT_ADMIN` authorization role.

Infrastructure Provider updating the Site must be the owner of the Site.

Tenant updating the Site must have access to the Site and can only update Tenant specific attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param siteId ID of the Site
 @return ApiUpdateSiteRequest
*/
func (a *SiteAPIService) UpdateSite(ctx context.Context, org string, siteId string) ApiUpdateSiteRequest {
	return ApiUpdateSiteRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return Site
func (a *SiteAPIService) UpdateSiteExecute(r ApiUpdateSiteRequest) (*Site, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Site
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SiteAPIService.UpdateSite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/site/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.siteUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
