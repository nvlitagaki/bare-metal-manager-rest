/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OperatingSystemAPIService OperatingSystemAPI service
type OperatingSystemAPIService service

type ApiCreateOperatingSystemRequest struct {
	ctx context.Context
	ApiService *OperatingSystemAPIService
	org string
	operatingSystemCreateRequest *OperatingSystemCreateRequest
}

func (r ApiCreateOperatingSystemRequest) OperatingSystemCreateRequest(operatingSystemCreateRequest OperatingSystemCreateRequest) ApiCreateOperatingSystemRequest {
	r.operatingSystemCreateRequest = &operatingSystemCreateRequest
	return r
}

func (r ApiCreateOperatingSystemRequest) Execute() (*OperatingSystem, *http.Response, error) {
	return r.ApiService.CreateOperatingSystemExecute(r)
}

/*
CreateOperatingSystem Create Operating System

Create an Operating System for the org.

Either `infrastructureProviderId` or `tenantId` must be provided in request data. Both cannot be provided at the same time.

If `infrastructureProviderId` is provided in request data, then org must have an Infrastructure Provider entity and its ID should match the query param value. User must have `FORGE_PROVIDER_ADMIN` role.

If `tenantId` is provided in request data, then org must have a Tenant entity and its ID should match the query param value. User must have `FORGE_TENANT_ADMIN` role.

Only Tenants are allowed to create Operating System for MVP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiCreateOperatingSystemRequest
*/
func (a *OperatingSystemAPIService) CreateOperatingSystem(ctx context.Context, org string) ApiCreateOperatingSystemRequest {
	return ApiCreateOperatingSystemRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return OperatingSystem
func (a *OperatingSystemAPIService) CreateOperatingSystemExecute(r ApiCreateOperatingSystemRequest) (*OperatingSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperatingSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatingSystemAPIService.CreateOperatingSystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/operating-system"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operatingSystemCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOperatingSystemRequest struct {
	ctx context.Context
	ApiService *OperatingSystemAPIService
	org string
	operatingSystemId string
}

func (r ApiDeleteOperatingSystemRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOperatingSystemExecute(r)
}

/*
DeleteOperatingSystem Delete Operating System

Delete an Operating System by ID

If the Operating System has `infrastructureProviderId` set, then org must have an Infrastructure Provider entity and its ID should match the Operating System Infrastructure Provider ID. User must have `FORGE_PROVIDER_ADMIN` authorization role.

If the Operating System has `tenantId` set, then org must have a Tenant entity and its ID should match the Operating System Tenant ID. User must have `FORGE_TENANT_ADMIN` authorization role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param operatingSystemId ID of the Operating System
 @return ApiDeleteOperatingSystemRequest
*/
func (a *OperatingSystemAPIService) DeleteOperatingSystem(ctx context.Context, org string, operatingSystemId string) ApiDeleteOperatingSystemRequest {
	return ApiDeleteOperatingSystemRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		operatingSystemId: operatingSystemId,
	}
}

// Execute executes the request
func (a *OperatingSystemAPIService) DeleteOperatingSystemExecute(r ApiDeleteOperatingSystemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatingSystemAPIService.DeleteOperatingSystem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/operating-system/{operatingSystemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operatingSystemId"+"}", url.PathEscape(parameterValueToString(r.operatingSystemId, "operatingSystemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllOperatingSystemRequest struct {
	ctx context.Context
	ApiService *OperatingSystemAPIService
	org string
	siteId *string
	type_ *string
	status *string
	query *string
	includeRelation *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// Filter Operating Systems by Site ID.  Can be specified multiple times to filter on more than one ID.
func (r ApiGetAllOperatingSystemRequest) SiteId(siteId string) ApiGetAllOperatingSystemRequest {
	r.siteId = &siteId
	return r
}

// Filter Operating Systems by Type
func (r ApiGetAllOperatingSystemRequest) Type_(type_ string) ApiGetAllOperatingSystemRequest {
	r.type_ = &type_
	return r
}

// Filter Operating Systems by Status.  Can be specified multiple times to filter on more than one status.
func (r ApiGetAllOperatingSystemRequest) Status(status string) ApiGetAllOperatingSystemRequest {
	r.status = &status
	return r
}

// Provide query to search for matches. Input will be matched against name, description and status fields
func (r ApiGetAllOperatingSystemRequest) Query(query string) ApiGetAllOperatingSystemRequest {
	r.query = &query
	return r
}

// Related entity to expand
func (r ApiGetAllOperatingSystemRequest) IncludeRelation(includeRelation string) ApiGetAllOperatingSystemRequest {
	r.includeRelation = &includeRelation
	return r
}

// Page number for pagination query
func (r ApiGetAllOperatingSystemRequest) PageNumber(pageNumber int32) ApiGetAllOperatingSystemRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllOperatingSystemRequest) PageSize(pageSize int32) ApiGetAllOperatingSystemRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllOperatingSystemRequest) OrderBy(orderBy string) ApiGetAllOperatingSystemRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllOperatingSystemRequest) Execute() ([]OperatingSystem, *http.Response, error) {
	return r.ApiService.GetAllOperatingSystemExecute(r)
}

/*
GetAllOperatingSystem Retrieve all Operating Systems

Get an Operating System by ID

If the Operating System has `infrastructureProviderId` set, then org must have an Infrastructure Provider entity and its ID should match the Operating System Infrastructure Provider ID. User must have `FORGE_PROVIDER_ADMIN` authorization role.

If the Operating System has `tenantId` set, then org must have a Tenant entity and its ID should match the Operating System Tenant ID. User must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllOperatingSystemRequest
*/
func (a *OperatingSystemAPIService) GetAllOperatingSystem(ctx context.Context, org string) ApiGetAllOperatingSystemRequest {
	return ApiGetAllOperatingSystemRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []OperatingSystem
func (a *OperatingSystemAPIService) GetAllOperatingSystemExecute(r ApiGetAllOperatingSystemRequest) ([]OperatingSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OperatingSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatingSystemAPIService.GetAllOperatingSystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/operating-system"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "form", "")
	}
	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", defaultValue, "form", "")
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOperatingSystemRequest struct {
	ctx context.Context
	ApiService *OperatingSystemAPIService
	org string
	operatingSystemId string
	includeRelation *string
}

// Related entity to expand
func (r ApiGetOperatingSystemRequest) IncludeRelation(includeRelation string) ApiGetOperatingSystemRequest {
	r.includeRelation = &includeRelation
	return r
}

func (r ApiGetOperatingSystemRequest) Execute() (*OperatingSystem, *http.Response, error) {
	return r.ApiService.GetOperatingSystemExecute(r)
}

/*
GetOperatingSystem Retrieve Operating System

Get an Operating System by ID

If the Operating System has `infrastructureProviderId` set, then org must have an Infrastructure Provider entity and its ID should match the Operating System Infrastructure Provider ID. User must have `FORGE_PROVIDER_ADMIN` authorization role.

If the Operating System has `tenantId` set, then org must have a Tenant entity and its ID should match the Operating System Tenant ID. User must have `FORGE_TENANT_ADMIN` role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param operatingSystemId ID of the Operating System
 @return ApiGetOperatingSystemRequest
*/
func (a *OperatingSystemAPIService) GetOperatingSystem(ctx context.Context, org string, operatingSystemId string) ApiGetOperatingSystemRequest {
	return ApiGetOperatingSystemRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		operatingSystemId: operatingSystemId,
	}
}

// Execute executes the request
//  @return OperatingSystem
func (a *OperatingSystemAPIService) GetOperatingSystemExecute(r ApiGetOperatingSystemRequest) (*OperatingSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperatingSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatingSystemAPIService.GetOperatingSystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/operating-system/{operatingSystemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operatingSystemId"+"}", url.PathEscape(parameterValueToString(r.operatingSystemId, "operatingSystemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeRelation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRelation", r.includeRelation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOperatingSystemRequest struct {
	ctx context.Context
	ApiService *OperatingSystemAPIService
	org string
	operatingSystemId string
	operatingSystemUpdateRequest *OperatingSystemUpdateRequest
}

func (r ApiUpdateOperatingSystemRequest) OperatingSystemUpdateRequest(operatingSystemUpdateRequest OperatingSystemUpdateRequest) ApiUpdateOperatingSystemRequest {
	r.operatingSystemUpdateRequest = &operatingSystemUpdateRequest
	return r
}

func (r ApiUpdateOperatingSystemRequest) Execute() (*OperatingSystem, *http.Response, error) {
	return r.ApiService.UpdateOperatingSystemExecute(r)
}

/*
UpdateOperatingSystem Update Operating System

Update an Operating System by ID

If the Operating System has `infrastructureProviderId` set, then org must have an Infrastructure Provider entity and its ID should match the Operating System Infrastructure Provider ID. User must have `FORGE_PROVIDER_ADMIN` authorization role. Provider must own the Operating System.

If the Operating System has `tenantId` set, then org must have a Tenant entity and its ID should match the Operating System Tenant ID. User must have `FORGE_TENANT_ADMIN` role. Tenant must own the Operating System.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param operatingSystemId ID of the Operating System
 @return ApiUpdateOperatingSystemRequest
*/
func (a *OperatingSystemAPIService) UpdateOperatingSystem(ctx context.Context, org string, operatingSystemId string) ApiUpdateOperatingSystemRequest {
	return ApiUpdateOperatingSystemRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		operatingSystemId: operatingSystemId,
	}
}

// Execute executes the request
//  @return OperatingSystem
func (a *OperatingSystemAPIService) UpdateOperatingSystemExecute(r ApiUpdateOperatingSystemRequest) (*OperatingSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperatingSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OperatingSystemAPIService.UpdateOperatingSystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/operating-system/{operatingSystemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"operatingSystemId"+"}", url.PathEscape(parameterValueToString(r.operatingSystemId, "operatingSystemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operatingSystemUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
