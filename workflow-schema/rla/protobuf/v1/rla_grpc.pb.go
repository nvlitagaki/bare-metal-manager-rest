// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: rla.proto

package rla

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RLA_Version_FullMethodName                  = "/v1.RLA/Version"
	RLA_CreateExpectedRack_FullMethodName       = "/v1.RLA/CreateExpectedRack"
	RLA_PatchRack_FullMethodName                = "/v1.RLA/PatchRack"
	RLA_GetRackInfoByID_FullMethodName          = "/v1.RLA/GetRackInfoByID"
	RLA_GetRackInfoBySerial_FullMethodName      = "/v1.RLA/GetRackInfoBySerial"
	RLA_GetComponentInfoByID_FullMethodName     = "/v1.RLA/GetComponentInfoByID"
	RLA_GetComponentInfoBySerial_FullMethodName = "/v1.RLA/GetComponentInfoBySerial"
	RLA_GetListOfRacks_FullMethodName           = "/v1.RLA/GetListOfRacks"
	RLA_CreateNVLDomain_FullMethodName          = "/v1.RLA/CreateNVLDomain"
	RLA_AttachRacksToNVLDomain_FullMethodName   = "/v1.RLA/AttachRacksToNVLDomain"
	RLA_DetachRacksFromNVLDomain_FullMethodName = "/v1.RLA/DetachRacksFromNVLDomain"
	RLA_GetListOfNVLDomains_FullMethodName      = "/v1.RLA/GetListOfNVLDomains"
	RLA_GetRacksForNVLDomain_FullMethodName     = "/v1.RLA/GetRacksForNVLDomain"
	RLA_UpgradeFirmware_FullMethodName          = "/v1.RLA/UpgradeFirmware"
	RLA_GetExpectedComponents_FullMethodName    = "/v1.RLA/GetExpectedComponents"
	RLA_GetActualComponents_FullMethodName      = "/v1.RLA/GetActualComponents"
	RLA_ValidateComponents_FullMethodName       = "/v1.RLA/ValidateComponents"
	RLA_PowerOnRack_FullMethodName              = "/v1.RLA/PowerOnRack"
	RLA_PowerOffRack_FullMethodName             = "/v1.RLA/PowerOffRack"
	RLA_PowerResetRack_FullMethodName           = "/v1.RLA/PowerResetRack"
	RLA_ListTasks_FullMethodName                = "/v1.RLA/ListTasks"
	RLA_GetTasksByIDs_FullMethodName            = "/v1.RLA/GetTasksByIDs"
)

// RLAClient is the client API for RLA service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RLAClient interface {
	// What version of RLA is this service running?
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*BuildInfo, error)
	CreateExpectedRack(ctx context.Context, in *CreateExpectedRackRequest, opts ...grpc.CallOption) (*CreateExpectedRackResponse, error)
	PatchRack(ctx context.Context, in *PatchRackRequest, opts ...grpc.CallOption) (*PatchRackResponse, error)
	GetRackInfoByID(ctx context.Context, in *GetRackInfoByIDRequest, opts ...grpc.CallOption) (*GetRackInfoResponse, error)
	GetRackInfoBySerial(ctx context.Context, in *GetRackInfoBySerialRequest, opts ...grpc.CallOption) (*GetRackInfoResponse, error)
	GetComponentInfoByID(ctx context.Context, in *GetComponentInfoByIDRequest, opts ...grpc.CallOption) (*GetComponentInfoResponse, error)
	GetComponentInfoBySerial(ctx context.Context, in *GetComponentInfoBySerialRequest, opts ...grpc.CallOption) (*GetComponentInfoResponse, error)
	GetListOfRacks(ctx context.Context, in *GetListOfRacksRequest, opts ...grpc.CallOption) (*GetListOfRacksResponse, error)
	CreateNVLDomain(ctx context.Context, in *CreateNVLDomainRequest, opts ...grpc.CallOption) (*CreateNVLDomainResponse, error)
	AttachRacksToNVLDomain(ctx context.Context, in *AttachRacksToNVLDomainRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DetachRacksFromNVLDomain(ctx context.Context, in *DetachRacksFromNVLDomainRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetListOfNVLDomains(ctx context.Context, in *GetListOfNVLDomainsRequest, opts ...grpc.CallOption) (*GetListOfNVLDomainsResponse, error)
	GetRacksForNVLDomain(ctx context.Context, in *GetRacksForNVLDomainRequest, opts ...grpc.CallOption) (*GetRacksForNVLDomainResponse, error)
	UpgradeFirmware(ctx context.Context, in *UpgradeFirmwareRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	// Components APIs
	GetExpectedComponents(ctx context.Context, in *GetExpectedComponentsRequest, opts ...grpc.CallOption) (*GetExpectedComponentsResponse, error)
	GetActualComponents(ctx context.Context, in *GetActualComponentsRequest, opts ...grpc.CallOption) (*GetActualComponentsResponse, error)
	ValidateComponents(ctx context.Context, in *ValidateComponentsRequest, opts ...grpc.CallOption) (*ValidateComponentsResponse, error)
	// Power control a rack or a rack's specified components
	PowerOnRack(ctx context.Context, in *PowerOnRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	PowerOffRack(ctx context.Context, in *PowerOffRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	PowerResetRack(ctx context.Context, in *PowerResetRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	// Query for tasks
	ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error)
	GetTasksByIDs(ctx context.Context, in *GetTasksByIDsRequest, opts ...grpc.CallOption) (*GetTasksByIDsResponse, error)
}

type rLAClient struct {
	cc grpc.ClientConnInterface
}

func NewRLAClient(cc grpc.ClientConnInterface) RLAClient {
	return &rLAClient{cc}
}

func (c *rLAClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*BuildInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildInfo)
	err := c.cc.Invoke(ctx, RLA_Version_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) CreateExpectedRack(ctx context.Context, in *CreateExpectedRackRequest, opts ...grpc.CallOption) (*CreateExpectedRackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateExpectedRackResponse)
	err := c.cc.Invoke(ctx, RLA_CreateExpectedRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PatchRack(ctx context.Context, in *PatchRackRequest, opts ...grpc.CallOption) (*PatchRackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchRackResponse)
	err := c.cc.Invoke(ctx, RLA_PatchRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetRackInfoByID(ctx context.Context, in *GetRackInfoByIDRequest, opts ...grpc.CallOption) (*GetRackInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRackInfoResponse)
	err := c.cc.Invoke(ctx, RLA_GetRackInfoByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetRackInfoBySerial(ctx context.Context, in *GetRackInfoBySerialRequest, opts ...grpc.CallOption) (*GetRackInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRackInfoResponse)
	err := c.cc.Invoke(ctx, RLA_GetRackInfoBySerial_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetComponentInfoByID(ctx context.Context, in *GetComponentInfoByIDRequest, opts ...grpc.CallOption) (*GetComponentInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetComponentInfoResponse)
	err := c.cc.Invoke(ctx, RLA_GetComponentInfoByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetComponentInfoBySerial(ctx context.Context, in *GetComponentInfoBySerialRequest, opts ...grpc.CallOption) (*GetComponentInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetComponentInfoResponse)
	err := c.cc.Invoke(ctx, RLA_GetComponentInfoBySerial_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetListOfRacks(ctx context.Context, in *GetListOfRacksRequest, opts ...grpc.CallOption) (*GetListOfRacksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetListOfRacksResponse)
	err := c.cc.Invoke(ctx, RLA_GetListOfRacks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) CreateNVLDomain(ctx context.Context, in *CreateNVLDomainRequest, opts ...grpc.CallOption) (*CreateNVLDomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNVLDomainResponse)
	err := c.cc.Invoke(ctx, RLA_CreateNVLDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) AttachRacksToNVLDomain(ctx context.Context, in *AttachRacksToNVLDomainRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_AttachRacksToNVLDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) DetachRacksFromNVLDomain(ctx context.Context, in *DetachRacksFromNVLDomainRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_DetachRacksFromNVLDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetListOfNVLDomains(ctx context.Context, in *GetListOfNVLDomainsRequest, opts ...grpc.CallOption) (*GetListOfNVLDomainsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetListOfNVLDomainsResponse)
	err := c.cc.Invoke(ctx, RLA_GetListOfNVLDomains_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetRacksForNVLDomain(ctx context.Context, in *GetRacksForNVLDomainRequest, opts ...grpc.CallOption) (*GetRacksForNVLDomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRacksForNVLDomainResponse)
	err := c.cc.Invoke(ctx, RLA_GetRacksForNVLDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) UpgradeFirmware(ctx context.Context, in *UpgradeFirmwareRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_UpgradeFirmware_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetExpectedComponents(ctx context.Context, in *GetExpectedComponentsRequest, opts ...grpc.CallOption) (*GetExpectedComponentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExpectedComponentsResponse)
	err := c.cc.Invoke(ctx, RLA_GetExpectedComponents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetActualComponents(ctx context.Context, in *GetActualComponentsRequest, opts ...grpc.CallOption) (*GetActualComponentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActualComponentsResponse)
	err := c.cc.Invoke(ctx, RLA_GetActualComponents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) ValidateComponents(ctx context.Context, in *ValidateComponentsRequest, opts ...grpc.CallOption) (*ValidateComponentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateComponentsResponse)
	err := c.cc.Invoke(ctx, RLA_ValidateComponents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PowerOnRack(ctx context.Context, in *PowerOnRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_PowerOnRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PowerOffRack(ctx context.Context, in *PowerOffRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_PowerOffRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PowerResetRack(ctx context.Context, in *PowerResetRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_PowerResetRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTasksResponse)
	err := c.cc.Invoke(ctx, RLA_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetTasksByIDs(ctx context.Context, in *GetTasksByIDsRequest, opts ...grpc.CallOption) (*GetTasksByIDsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTasksByIDsResponse)
	err := c.cc.Invoke(ctx, RLA_GetTasksByIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RLAServer is the server API for RLA service.
// All implementations should embed UnimplementedRLAServer
// for forward compatibility.
type RLAServer interface {
	// What version of RLA is this service running?
	Version(context.Context, *VersionRequest) (*BuildInfo, error)
	CreateExpectedRack(context.Context, *CreateExpectedRackRequest) (*CreateExpectedRackResponse, error)
	PatchRack(context.Context, *PatchRackRequest) (*PatchRackResponse, error)
	GetRackInfoByID(context.Context, *GetRackInfoByIDRequest) (*GetRackInfoResponse, error)
	GetRackInfoBySerial(context.Context, *GetRackInfoBySerialRequest) (*GetRackInfoResponse, error)
	GetComponentInfoByID(context.Context, *GetComponentInfoByIDRequest) (*GetComponentInfoResponse, error)
	GetComponentInfoBySerial(context.Context, *GetComponentInfoBySerialRequest) (*GetComponentInfoResponse, error)
	GetListOfRacks(context.Context, *GetListOfRacksRequest) (*GetListOfRacksResponse, error)
	CreateNVLDomain(context.Context, *CreateNVLDomainRequest) (*CreateNVLDomainResponse, error)
	AttachRacksToNVLDomain(context.Context, *AttachRacksToNVLDomainRequest) (*emptypb.Empty, error)
	DetachRacksFromNVLDomain(context.Context, *DetachRacksFromNVLDomainRequest) (*emptypb.Empty, error)
	GetListOfNVLDomains(context.Context, *GetListOfNVLDomainsRequest) (*GetListOfNVLDomainsResponse, error)
	GetRacksForNVLDomain(context.Context, *GetRacksForNVLDomainRequest) (*GetRacksForNVLDomainResponse, error)
	UpgradeFirmware(context.Context, *UpgradeFirmwareRequest) (*SubmitTaskResponse, error)
	// Components APIs
	GetExpectedComponents(context.Context, *GetExpectedComponentsRequest) (*GetExpectedComponentsResponse, error)
	GetActualComponents(context.Context, *GetActualComponentsRequest) (*GetActualComponentsResponse, error)
	ValidateComponents(context.Context, *ValidateComponentsRequest) (*ValidateComponentsResponse, error)
	// Power control a rack or a rack's specified components
	PowerOnRack(context.Context, *PowerOnRackRequest) (*SubmitTaskResponse, error)
	PowerOffRack(context.Context, *PowerOffRackRequest) (*SubmitTaskResponse, error)
	PowerResetRack(context.Context, *PowerResetRackRequest) (*SubmitTaskResponse, error)
	// Query for tasks
	ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error)
	GetTasksByIDs(context.Context, *GetTasksByIDsRequest) (*GetTasksByIDsResponse, error)
}

// UnimplementedRLAServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRLAServer struct{}

func (UnimplementedRLAServer) Version(context.Context, *VersionRequest) (*BuildInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedRLAServer) CreateExpectedRack(context.Context, *CreateExpectedRackRequest) (*CreateExpectedRackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateExpectedRack not implemented")
}
func (UnimplementedRLAServer) PatchRack(context.Context, *PatchRackRequest) (*PatchRackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PatchRack not implemented")
}
func (UnimplementedRLAServer) GetRackInfoByID(context.Context, *GetRackInfoByIDRequest) (*GetRackInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRackInfoByID not implemented")
}
func (UnimplementedRLAServer) GetRackInfoBySerial(context.Context, *GetRackInfoBySerialRequest) (*GetRackInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRackInfoBySerial not implemented")
}
func (UnimplementedRLAServer) GetComponentInfoByID(context.Context, *GetComponentInfoByIDRequest) (*GetComponentInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetComponentInfoByID not implemented")
}
func (UnimplementedRLAServer) GetComponentInfoBySerial(context.Context, *GetComponentInfoBySerialRequest) (*GetComponentInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetComponentInfoBySerial not implemented")
}
func (UnimplementedRLAServer) GetListOfRacks(context.Context, *GetListOfRacksRequest) (*GetListOfRacksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetListOfRacks not implemented")
}
func (UnimplementedRLAServer) CreateNVLDomain(context.Context, *CreateNVLDomainRequest) (*CreateNVLDomainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateNVLDomain not implemented")
}
func (UnimplementedRLAServer) AttachRacksToNVLDomain(context.Context, *AttachRacksToNVLDomainRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AttachRacksToNVLDomain not implemented")
}
func (UnimplementedRLAServer) DetachRacksFromNVLDomain(context.Context, *DetachRacksFromNVLDomainRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DetachRacksFromNVLDomain not implemented")
}
func (UnimplementedRLAServer) GetListOfNVLDomains(context.Context, *GetListOfNVLDomainsRequest) (*GetListOfNVLDomainsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetListOfNVLDomains not implemented")
}
func (UnimplementedRLAServer) GetRacksForNVLDomain(context.Context, *GetRacksForNVLDomainRequest) (*GetRacksForNVLDomainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRacksForNVLDomain not implemented")
}
func (UnimplementedRLAServer) UpgradeFirmware(context.Context, *UpgradeFirmwareRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpgradeFirmware not implemented")
}
func (UnimplementedRLAServer) GetExpectedComponents(context.Context, *GetExpectedComponentsRequest) (*GetExpectedComponentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetExpectedComponents not implemented")
}
func (UnimplementedRLAServer) GetActualComponents(context.Context, *GetActualComponentsRequest) (*GetActualComponentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetActualComponents not implemented")
}
func (UnimplementedRLAServer) ValidateComponents(context.Context, *ValidateComponentsRequest) (*ValidateComponentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateComponents not implemented")
}
func (UnimplementedRLAServer) PowerOnRack(context.Context, *PowerOnRackRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PowerOnRack not implemented")
}
func (UnimplementedRLAServer) PowerOffRack(context.Context, *PowerOffRackRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PowerOffRack not implemented")
}
func (UnimplementedRLAServer) PowerResetRack(context.Context, *PowerResetRackRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PowerResetRack not implemented")
}
func (UnimplementedRLAServer) ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedRLAServer) GetTasksByIDs(context.Context, *GetTasksByIDsRequest) (*GetTasksByIDsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTasksByIDs not implemented")
}
func (UnimplementedRLAServer) testEmbeddedByValue() {}

// UnsafeRLAServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RLAServer will
// result in compilation errors.
type UnsafeRLAServer interface {
	mustEmbedUnimplementedRLAServer()
}

func RegisterRLAServer(s grpc.ServiceRegistrar, srv RLAServer) {
	// If the following call panics, it indicates UnimplementedRLAServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RLA_ServiceDesc, srv)
}

func _RLA_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_CreateExpectedRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExpectedRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).CreateExpectedRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_CreateExpectedRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).CreateExpectedRack(ctx, req.(*CreateExpectedRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PatchRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PatchRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PatchRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PatchRack(ctx, req.(*PatchRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetRackInfoByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRackInfoByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetRackInfoByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetRackInfoByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetRackInfoByID(ctx, req.(*GetRackInfoByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetRackInfoBySerial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRackInfoBySerialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetRackInfoBySerial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetRackInfoBySerial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetRackInfoBySerial(ctx, req.(*GetRackInfoBySerialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetComponentInfoByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComponentInfoByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetComponentInfoByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetComponentInfoByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetComponentInfoByID(ctx, req.(*GetComponentInfoByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetComponentInfoBySerial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComponentInfoBySerialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetComponentInfoBySerial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetComponentInfoBySerial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetComponentInfoBySerial(ctx, req.(*GetComponentInfoBySerialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetListOfRacks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListOfRacksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetListOfRacks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetListOfRacks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetListOfRacks(ctx, req.(*GetListOfRacksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_CreateNVLDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNVLDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).CreateNVLDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_CreateNVLDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).CreateNVLDomain(ctx, req.(*CreateNVLDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_AttachRacksToNVLDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachRacksToNVLDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).AttachRacksToNVLDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_AttachRacksToNVLDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).AttachRacksToNVLDomain(ctx, req.(*AttachRacksToNVLDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_DetachRacksFromNVLDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachRacksFromNVLDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).DetachRacksFromNVLDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_DetachRacksFromNVLDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).DetachRacksFromNVLDomain(ctx, req.(*DetachRacksFromNVLDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetListOfNVLDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListOfNVLDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetListOfNVLDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetListOfNVLDomains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetListOfNVLDomains(ctx, req.(*GetListOfNVLDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetRacksForNVLDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRacksForNVLDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetRacksForNVLDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetRacksForNVLDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetRacksForNVLDomain(ctx, req.(*GetRacksForNVLDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_UpgradeFirmware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeFirmwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).UpgradeFirmware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_UpgradeFirmware_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).UpgradeFirmware(ctx, req.(*UpgradeFirmwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetExpectedComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExpectedComponentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetExpectedComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetExpectedComponents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetExpectedComponents(ctx, req.(*GetExpectedComponentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetActualComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActualComponentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetActualComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetActualComponents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetActualComponents(ctx, req.(*GetActualComponentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_ValidateComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateComponentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).ValidateComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_ValidateComponents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).ValidateComponents(ctx, req.(*ValidateComponentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PowerOnRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerOnRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PowerOnRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PowerOnRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PowerOnRack(ctx, req.(*PowerOnRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PowerOffRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerOffRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PowerOffRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PowerOffRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PowerOffRack(ctx, req.(*PowerOffRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PowerResetRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerResetRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PowerResetRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PowerResetRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PowerResetRack(ctx, req.(*PowerResetRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).ListTasks(ctx, req.(*ListTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetTasksByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTasksByIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetTasksByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetTasksByIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetTasksByIDs(ctx, req.(*GetTasksByIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RLA_ServiceDesc is the grpc.ServiceDesc for RLA service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RLA_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.RLA",
	HandlerType: (*RLAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _RLA_Version_Handler,
		},
		{
			MethodName: "CreateExpectedRack",
			Handler:    _RLA_CreateExpectedRack_Handler,
		},
		{
			MethodName: "PatchRack",
			Handler:    _RLA_PatchRack_Handler,
		},
		{
			MethodName: "GetRackInfoByID",
			Handler:    _RLA_GetRackInfoByID_Handler,
		},
		{
			MethodName: "GetRackInfoBySerial",
			Handler:    _RLA_GetRackInfoBySerial_Handler,
		},
		{
			MethodName: "GetComponentInfoByID",
			Handler:    _RLA_GetComponentInfoByID_Handler,
		},
		{
			MethodName: "GetComponentInfoBySerial",
			Handler:    _RLA_GetComponentInfoBySerial_Handler,
		},
		{
			MethodName: "GetListOfRacks",
			Handler:    _RLA_GetListOfRacks_Handler,
		},
		{
			MethodName: "CreateNVLDomain",
			Handler:    _RLA_CreateNVLDomain_Handler,
		},
		{
			MethodName: "AttachRacksToNVLDomain",
			Handler:    _RLA_AttachRacksToNVLDomain_Handler,
		},
		{
			MethodName: "DetachRacksFromNVLDomain",
			Handler:    _RLA_DetachRacksFromNVLDomain_Handler,
		},
		{
			MethodName: "GetListOfNVLDomains",
			Handler:    _RLA_GetListOfNVLDomains_Handler,
		},
		{
			MethodName: "GetRacksForNVLDomain",
			Handler:    _RLA_GetRacksForNVLDomain_Handler,
		},
		{
			MethodName: "UpgradeFirmware",
			Handler:    _RLA_UpgradeFirmware_Handler,
		},
		{
			MethodName: "GetExpectedComponents",
			Handler:    _RLA_GetExpectedComponents_Handler,
		},
		{
			MethodName: "GetActualComponents",
			Handler:    _RLA_GetActualComponents_Handler,
		},
		{
			MethodName: "ValidateComponents",
			Handler:    _RLA_ValidateComponents_Handler,
		},
		{
			MethodName: "PowerOnRack",
			Handler:    _RLA_PowerOnRack_Handler,
		},
		{
			MethodName: "PowerOffRack",
			Handler:    _RLA_PowerOffRack_Handler,
		},
		{
			MethodName: "PowerResetRack",
			Handler:    _RLA_PowerResetRack_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _RLA_ListTasks_Handler,
		},
		{
			MethodName: "GetTasksByIDs",
			Handler:    _RLA_GetTasksByIDs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rla.proto",
}
