//
// SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v5.29.3
// source: rla.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RLA_Version_FullMethodName                  = "/v1.RLA/Version"
	RLA_CreateExpectedRack_FullMethodName       = "/v1.RLA/CreateExpectedRack"
	RLA_PatchRack_FullMethodName                = "/v1.RLA/PatchRack"
	RLA_GetRackInfoByID_FullMethodName          = "/v1.RLA/GetRackInfoByID"
	RLA_GetRackInfoBySerial_FullMethodName      = "/v1.RLA/GetRackInfoBySerial"
	RLA_GetComponentInfoByID_FullMethodName     = "/v1.RLA/GetComponentInfoByID"
	RLA_GetComponentInfoBySerial_FullMethodName = "/v1.RLA/GetComponentInfoBySerial"
	RLA_GetListOfRacks_FullMethodName           = "/v1.RLA/GetListOfRacks"
	RLA_CreateNVLDomain_FullMethodName          = "/v1.RLA/CreateNVLDomain"
	RLA_AttachRacksToNVLDomain_FullMethodName   = "/v1.RLA/AttachRacksToNVLDomain"
	RLA_DetachRacksFromNVLDomain_FullMethodName = "/v1.RLA/DetachRacksFromNVLDomain"
	RLA_GetListOfNVLDomains_FullMethodName      = "/v1.RLA/GetListOfNVLDomains"
	RLA_GetRacksForNVLDomain_FullMethodName     = "/v1.RLA/GetRacksForNVLDomain"
	RLA_UpgradeFirmware_FullMethodName          = "/v1.RLA/UpgradeFirmware"
	RLA_BringUpRack_FullMethodName              = "/v1.RLA/BringUpRack"
	RLA_GetComponents_FullMethodName            = "/v1.RLA/GetComponents"
	RLA_ValidateComponents_FullMethodName       = "/v1.RLA/ValidateComponents"
	RLA_AddComponent_FullMethodName             = "/v1.RLA/AddComponent"
	RLA_PatchComponent_FullMethodName           = "/v1.RLA/PatchComponent"
	RLA_DeleteComponent_FullMethodName          = "/v1.RLA/DeleteComponent"
	RLA_PowerOnRack_FullMethodName              = "/v1.RLA/PowerOnRack"
	RLA_PowerOffRack_FullMethodName             = "/v1.RLA/PowerOffRack"
	RLA_PowerResetRack_FullMethodName           = "/v1.RLA/PowerResetRack"
	RLA_ListTasks_FullMethodName                = "/v1.RLA/ListTasks"
	RLA_GetTasksByIDs_FullMethodName            = "/v1.RLA/GetTasksByIDs"
	RLA_CreateOperationRule_FullMethodName      = "/v1.RLA/CreateOperationRule"
	RLA_UpdateOperationRule_FullMethodName      = "/v1.RLA/UpdateOperationRule"
	RLA_DeleteOperationRule_FullMethodName      = "/v1.RLA/DeleteOperationRule"
	RLA_GetOperationRule_FullMethodName         = "/v1.RLA/GetOperationRule"
	RLA_ListOperationRules_FullMethodName       = "/v1.RLA/ListOperationRules"
	RLA_SetRuleAsDefault_FullMethodName         = "/v1.RLA/SetRuleAsDefault"
	RLA_AssociateRuleWithRack_FullMethodName    = "/v1.RLA/AssociateRuleWithRack"
	RLA_DisassociateRuleFromRack_FullMethodName = "/v1.RLA/DisassociateRuleFromRack"
	RLA_GetRackRuleAssociation_FullMethodName   = "/v1.RLA/GetRackRuleAssociation"
	RLA_ListRackRuleAssociations_FullMethodName = "/v1.RLA/ListRackRuleAssociations"
)

// RLAClient is the client API for RLA service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RLAClient interface {
	// What version of RLA is this service running?
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*BuildInfo, error)
	CreateExpectedRack(ctx context.Context, in *CreateExpectedRackRequest, opts ...grpc.CallOption) (*CreateExpectedRackResponse, error)
	PatchRack(ctx context.Context, in *PatchRackRequest, opts ...grpc.CallOption) (*PatchRackResponse, error)
	GetRackInfoByID(ctx context.Context, in *GetRackInfoByIDRequest, opts ...grpc.CallOption) (*GetRackInfoResponse, error)
	GetRackInfoBySerial(ctx context.Context, in *GetRackInfoBySerialRequest, opts ...grpc.CallOption) (*GetRackInfoResponse, error)
	GetComponentInfoByID(ctx context.Context, in *GetComponentInfoByIDRequest, opts ...grpc.CallOption) (*GetComponentInfoResponse, error)
	GetComponentInfoBySerial(ctx context.Context, in *GetComponentInfoBySerialRequest, opts ...grpc.CallOption) (*GetComponentInfoResponse, error)
	GetListOfRacks(ctx context.Context, in *GetListOfRacksRequest, opts ...grpc.CallOption) (*GetListOfRacksResponse, error)
	CreateNVLDomain(ctx context.Context, in *CreateNVLDomainRequest, opts ...grpc.CallOption) (*CreateNVLDomainResponse, error)
	AttachRacksToNVLDomain(ctx context.Context, in *AttachRacksToNVLDomainRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DetachRacksFromNVLDomain(ctx context.Context, in *DetachRacksFromNVLDomainRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetListOfNVLDomains(ctx context.Context, in *GetListOfNVLDomainsRequest, opts ...grpc.CallOption) (*GetListOfNVLDomainsResponse, error)
	GetRacksForNVLDomain(ctx context.Context, in *GetRacksForNVLDomainRequest, opts ...grpc.CallOption) (*GetRacksForNVLDomainResponse, error)
	UpgradeFirmware(ctx context.Context, in *UpgradeFirmwareRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	// Bring up rack: power on, configure, and validate a new rack
	BringUpRack(ctx context.Context, in *BringUpRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	// Components APIs
	GetComponents(ctx context.Context, in *GetComponentsRequest, opts ...grpc.CallOption) (*GetComponentsResponse, error)
	ValidateComponents(ctx context.Context, in *ValidateComponentsRequest, opts ...grpc.CallOption) (*ValidateComponentsResponse, error)
	AddComponent(ctx context.Context, in *AddComponentRequest, opts ...grpc.CallOption) (*AddComponentResponse, error)
	PatchComponent(ctx context.Context, in *PatchComponentRequest, opts ...grpc.CallOption) (*PatchComponentResponse, error)
	DeleteComponent(ctx context.Context, in *DeleteComponentRequest, opts ...grpc.CallOption) (*DeleteComponentResponse, error)
	// Power control a rack or a rack's specified components
	PowerOnRack(ctx context.Context, in *PowerOnRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	PowerOffRack(ctx context.Context, in *PowerOffRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	PowerResetRack(ctx context.Context, in *PowerResetRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error)
	// Query for tasks
	ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error)
	GetTasksByIDs(ctx context.Context, in *GetTasksByIDsRequest, opts ...grpc.CallOption) (*GetTasksByIDsResponse, error)
	// Operation rules management
	CreateOperationRule(ctx context.Context, in *CreateOperationRuleRequest, opts ...grpc.CallOption) (*CreateOperationRuleResponse, error)
	UpdateOperationRule(ctx context.Context, in *UpdateOperationRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteOperationRule(ctx context.Context, in *DeleteOperationRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetOperationRule(ctx context.Context, in *GetOperationRuleRequest, opts ...grpc.CallOption) (*OperationRule, error)
	ListOperationRules(ctx context.Context, in *ListOperationRulesRequest, opts ...grpc.CallOption) (*ListOperationRulesResponse, error)
	SetRuleAsDefault(ctx context.Context, in *SetRuleAsDefaultRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Rack-rule associations
	AssociateRuleWithRack(ctx context.Context, in *AssociateRuleWithRackRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DisassociateRuleFromRack(ctx context.Context, in *DisassociateRuleFromRackRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetRackRuleAssociation(ctx context.Context, in *GetRackRuleAssociationRequest, opts ...grpc.CallOption) (*GetRackRuleAssociationResponse, error)
	ListRackRuleAssociations(ctx context.Context, in *ListRackRuleAssociationsRequest, opts ...grpc.CallOption) (*ListRackRuleAssociationsResponse, error)
}

type rLAClient struct {
	cc grpc.ClientConnInterface
}

func NewRLAClient(cc grpc.ClientConnInterface) RLAClient {
	return &rLAClient{cc}
}

func (c *rLAClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*BuildInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildInfo)
	err := c.cc.Invoke(ctx, RLA_Version_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) CreateExpectedRack(ctx context.Context, in *CreateExpectedRackRequest, opts ...grpc.CallOption) (*CreateExpectedRackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateExpectedRackResponse)
	err := c.cc.Invoke(ctx, RLA_CreateExpectedRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PatchRack(ctx context.Context, in *PatchRackRequest, opts ...grpc.CallOption) (*PatchRackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchRackResponse)
	err := c.cc.Invoke(ctx, RLA_PatchRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetRackInfoByID(ctx context.Context, in *GetRackInfoByIDRequest, opts ...grpc.CallOption) (*GetRackInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRackInfoResponse)
	err := c.cc.Invoke(ctx, RLA_GetRackInfoByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetRackInfoBySerial(ctx context.Context, in *GetRackInfoBySerialRequest, opts ...grpc.CallOption) (*GetRackInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRackInfoResponse)
	err := c.cc.Invoke(ctx, RLA_GetRackInfoBySerial_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetComponentInfoByID(ctx context.Context, in *GetComponentInfoByIDRequest, opts ...grpc.CallOption) (*GetComponentInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetComponentInfoResponse)
	err := c.cc.Invoke(ctx, RLA_GetComponentInfoByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetComponentInfoBySerial(ctx context.Context, in *GetComponentInfoBySerialRequest, opts ...grpc.CallOption) (*GetComponentInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetComponentInfoResponse)
	err := c.cc.Invoke(ctx, RLA_GetComponentInfoBySerial_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetListOfRacks(ctx context.Context, in *GetListOfRacksRequest, opts ...grpc.CallOption) (*GetListOfRacksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetListOfRacksResponse)
	err := c.cc.Invoke(ctx, RLA_GetListOfRacks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) CreateNVLDomain(ctx context.Context, in *CreateNVLDomainRequest, opts ...grpc.CallOption) (*CreateNVLDomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNVLDomainResponse)
	err := c.cc.Invoke(ctx, RLA_CreateNVLDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) AttachRacksToNVLDomain(ctx context.Context, in *AttachRacksToNVLDomainRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_AttachRacksToNVLDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) DetachRacksFromNVLDomain(ctx context.Context, in *DetachRacksFromNVLDomainRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_DetachRacksFromNVLDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetListOfNVLDomains(ctx context.Context, in *GetListOfNVLDomainsRequest, opts ...grpc.CallOption) (*GetListOfNVLDomainsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetListOfNVLDomainsResponse)
	err := c.cc.Invoke(ctx, RLA_GetListOfNVLDomains_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetRacksForNVLDomain(ctx context.Context, in *GetRacksForNVLDomainRequest, opts ...grpc.CallOption) (*GetRacksForNVLDomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRacksForNVLDomainResponse)
	err := c.cc.Invoke(ctx, RLA_GetRacksForNVLDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) UpgradeFirmware(ctx context.Context, in *UpgradeFirmwareRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_UpgradeFirmware_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) BringUpRack(ctx context.Context, in *BringUpRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_BringUpRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetComponents(ctx context.Context, in *GetComponentsRequest, opts ...grpc.CallOption) (*GetComponentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetComponentsResponse)
	err := c.cc.Invoke(ctx, RLA_GetComponents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) ValidateComponents(ctx context.Context, in *ValidateComponentsRequest, opts ...grpc.CallOption) (*ValidateComponentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateComponentsResponse)
	err := c.cc.Invoke(ctx, RLA_ValidateComponents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) AddComponent(ctx context.Context, in *AddComponentRequest, opts ...grpc.CallOption) (*AddComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddComponentResponse)
	err := c.cc.Invoke(ctx, RLA_AddComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PatchComponent(ctx context.Context, in *PatchComponentRequest, opts ...grpc.CallOption) (*PatchComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PatchComponentResponse)
	err := c.cc.Invoke(ctx, RLA_PatchComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) DeleteComponent(ctx context.Context, in *DeleteComponentRequest, opts ...grpc.CallOption) (*DeleteComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteComponentResponse)
	err := c.cc.Invoke(ctx, RLA_DeleteComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PowerOnRack(ctx context.Context, in *PowerOnRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_PowerOnRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PowerOffRack(ctx context.Context, in *PowerOffRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_PowerOffRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) PowerResetRack(ctx context.Context, in *PowerResetRackRequest, opts ...grpc.CallOption) (*SubmitTaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitTaskResponse)
	err := c.cc.Invoke(ctx, RLA_PowerResetRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTasksResponse)
	err := c.cc.Invoke(ctx, RLA_ListTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetTasksByIDs(ctx context.Context, in *GetTasksByIDsRequest, opts ...grpc.CallOption) (*GetTasksByIDsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTasksByIDsResponse)
	err := c.cc.Invoke(ctx, RLA_GetTasksByIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) CreateOperationRule(ctx context.Context, in *CreateOperationRuleRequest, opts ...grpc.CallOption) (*CreateOperationRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateOperationRuleResponse)
	err := c.cc.Invoke(ctx, RLA_CreateOperationRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) UpdateOperationRule(ctx context.Context, in *UpdateOperationRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_UpdateOperationRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) DeleteOperationRule(ctx context.Context, in *DeleteOperationRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_DeleteOperationRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetOperationRule(ctx context.Context, in *GetOperationRuleRequest, opts ...grpc.CallOption) (*OperationRule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationRule)
	err := c.cc.Invoke(ctx, RLA_GetOperationRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) ListOperationRules(ctx context.Context, in *ListOperationRulesRequest, opts ...grpc.CallOption) (*ListOperationRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOperationRulesResponse)
	err := c.cc.Invoke(ctx, RLA_ListOperationRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) SetRuleAsDefault(ctx context.Context, in *SetRuleAsDefaultRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_SetRuleAsDefault_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) AssociateRuleWithRack(ctx context.Context, in *AssociateRuleWithRackRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_AssociateRuleWithRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) DisassociateRuleFromRack(ctx context.Context, in *DisassociateRuleFromRackRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RLA_DisassociateRuleFromRack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) GetRackRuleAssociation(ctx context.Context, in *GetRackRuleAssociationRequest, opts ...grpc.CallOption) (*GetRackRuleAssociationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRackRuleAssociationResponse)
	err := c.cc.Invoke(ctx, RLA_GetRackRuleAssociation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rLAClient) ListRackRuleAssociations(ctx context.Context, in *ListRackRuleAssociationsRequest, opts ...grpc.CallOption) (*ListRackRuleAssociationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRackRuleAssociationsResponse)
	err := c.cc.Invoke(ctx, RLA_ListRackRuleAssociations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RLAServer is the server API for RLA service.
// All implementations must embed UnimplementedRLAServer
// for forward compatibility.
type RLAServer interface {
	// What version of RLA is this service running?
	Version(context.Context, *VersionRequest) (*BuildInfo, error)
	CreateExpectedRack(context.Context, *CreateExpectedRackRequest) (*CreateExpectedRackResponse, error)
	PatchRack(context.Context, *PatchRackRequest) (*PatchRackResponse, error)
	GetRackInfoByID(context.Context, *GetRackInfoByIDRequest) (*GetRackInfoResponse, error)
	GetRackInfoBySerial(context.Context, *GetRackInfoBySerialRequest) (*GetRackInfoResponse, error)
	GetComponentInfoByID(context.Context, *GetComponentInfoByIDRequest) (*GetComponentInfoResponse, error)
	GetComponentInfoBySerial(context.Context, *GetComponentInfoBySerialRequest) (*GetComponentInfoResponse, error)
	GetListOfRacks(context.Context, *GetListOfRacksRequest) (*GetListOfRacksResponse, error)
	CreateNVLDomain(context.Context, *CreateNVLDomainRequest) (*CreateNVLDomainResponse, error)
	AttachRacksToNVLDomain(context.Context, *AttachRacksToNVLDomainRequest) (*emptypb.Empty, error)
	DetachRacksFromNVLDomain(context.Context, *DetachRacksFromNVLDomainRequest) (*emptypb.Empty, error)
	GetListOfNVLDomains(context.Context, *GetListOfNVLDomainsRequest) (*GetListOfNVLDomainsResponse, error)
	GetRacksForNVLDomain(context.Context, *GetRacksForNVLDomainRequest) (*GetRacksForNVLDomainResponse, error)
	UpgradeFirmware(context.Context, *UpgradeFirmwareRequest) (*SubmitTaskResponse, error)
	// Bring up rack: power on, configure, and validate a new rack
	BringUpRack(context.Context, *BringUpRackRequest) (*SubmitTaskResponse, error)
	// Components APIs
	GetComponents(context.Context, *GetComponentsRequest) (*GetComponentsResponse, error)
	ValidateComponents(context.Context, *ValidateComponentsRequest) (*ValidateComponentsResponse, error)
	AddComponent(context.Context, *AddComponentRequest) (*AddComponentResponse, error)
	PatchComponent(context.Context, *PatchComponentRequest) (*PatchComponentResponse, error)
	DeleteComponent(context.Context, *DeleteComponentRequest) (*DeleteComponentResponse, error)
	// Power control a rack or a rack's specified components
	PowerOnRack(context.Context, *PowerOnRackRequest) (*SubmitTaskResponse, error)
	PowerOffRack(context.Context, *PowerOffRackRequest) (*SubmitTaskResponse, error)
	PowerResetRack(context.Context, *PowerResetRackRequest) (*SubmitTaskResponse, error)
	// Query for tasks
	ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error)
	GetTasksByIDs(context.Context, *GetTasksByIDsRequest) (*GetTasksByIDsResponse, error)
	// Operation rules management
	CreateOperationRule(context.Context, *CreateOperationRuleRequest) (*CreateOperationRuleResponse, error)
	UpdateOperationRule(context.Context, *UpdateOperationRuleRequest) (*emptypb.Empty, error)
	DeleteOperationRule(context.Context, *DeleteOperationRuleRequest) (*emptypb.Empty, error)
	GetOperationRule(context.Context, *GetOperationRuleRequest) (*OperationRule, error)
	ListOperationRules(context.Context, *ListOperationRulesRequest) (*ListOperationRulesResponse, error)
	SetRuleAsDefault(context.Context, *SetRuleAsDefaultRequest) (*emptypb.Empty, error)
	// Rack-rule associations
	AssociateRuleWithRack(context.Context, *AssociateRuleWithRackRequest) (*emptypb.Empty, error)
	DisassociateRuleFromRack(context.Context, *DisassociateRuleFromRackRequest) (*emptypb.Empty, error)
	GetRackRuleAssociation(context.Context, *GetRackRuleAssociationRequest) (*GetRackRuleAssociationResponse, error)
	ListRackRuleAssociations(context.Context, *ListRackRuleAssociationsRequest) (*ListRackRuleAssociationsResponse, error)
	mustEmbedUnimplementedRLAServer()
}

// UnimplementedRLAServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRLAServer struct{}

func (UnimplementedRLAServer) Version(context.Context, *VersionRequest) (*BuildInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedRLAServer) CreateExpectedRack(context.Context, *CreateExpectedRackRequest) (*CreateExpectedRackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateExpectedRack not implemented")
}
func (UnimplementedRLAServer) PatchRack(context.Context, *PatchRackRequest) (*PatchRackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PatchRack not implemented")
}
func (UnimplementedRLAServer) GetRackInfoByID(context.Context, *GetRackInfoByIDRequest) (*GetRackInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRackInfoByID not implemented")
}
func (UnimplementedRLAServer) GetRackInfoBySerial(context.Context, *GetRackInfoBySerialRequest) (*GetRackInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRackInfoBySerial not implemented")
}
func (UnimplementedRLAServer) GetComponentInfoByID(context.Context, *GetComponentInfoByIDRequest) (*GetComponentInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetComponentInfoByID not implemented")
}
func (UnimplementedRLAServer) GetComponentInfoBySerial(context.Context, *GetComponentInfoBySerialRequest) (*GetComponentInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetComponentInfoBySerial not implemented")
}
func (UnimplementedRLAServer) GetListOfRacks(context.Context, *GetListOfRacksRequest) (*GetListOfRacksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetListOfRacks not implemented")
}
func (UnimplementedRLAServer) CreateNVLDomain(context.Context, *CreateNVLDomainRequest) (*CreateNVLDomainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateNVLDomain not implemented")
}
func (UnimplementedRLAServer) AttachRacksToNVLDomain(context.Context, *AttachRacksToNVLDomainRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AttachRacksToNVLDomain not implemented")
}
func (UnimplementedRLAServer) DetachRacksFromNVLDomain(context.Context, *DetachRacksFromNVLDomainRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DetachRacksFromNVLDomain not implemented")
}
func (UnimplementedRLAServer) GetListOfNVLDomains(context.Context, *GetListOfNVLDomainsRequest) (*GetListOfNVLDomainsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetListOfNVLDomains not implemented")
}
func (UnimplementedRLAServer) GetRacksForNVLDomain(context.Context, *GetRacksForNVLDomainRequest) (*GetRacksForNVLDomainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRacksForNVLDomain not implemented")
}
func (UnimplementedRLAServer) UpgradeFirmware(context.Context, *UpgradeFirmwareRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpgradeFirmware not implemented")
}
func (UnimplementedRLAServer) BringUpRack(context.Context, *BringUpRackRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BringUpRack not implemented")
}
func (UnimplementedRLAServer) GetComponents(context.Context, *GetComponentsRequest) (*GetComponentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetComponents not implemented")
}
func (UnimplementedRLAServer) ValidateComponents(context.Context, *ValidateComponentsRequest) (*ValidateComponentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateComponents not implemented")
}
func (UnimplementedRLAServer) AddComponent(context.Context, *AddComponentRequest) (*AddComponentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddComponent not implemented")
}
func (UnimplementedRLAServer) PatchComponent(context.Context, *PatchComponentRequest) (*PatchComponentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PatchComponent not implemented")
}
func (UnimplementedRLAServer) DeleteComponent(context.Context, *DeleteComponentRequest) (*DeleteComponentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteComponent not implemented")
}
func (UnimplementedRLAServer) PowerOnRack(context.Context, *PowerOnRackRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PowerOnRack not implemented")
}
func (UnimplementedRLAServer) PowerOffRack(context.Context, *PowerOffRackRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PowerOffRack not implemented")
}
func (UnimplementedRLAServer) PowerResetRack(context.Context, *PowerResetRackRequest) (*SubmitTaskResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PowerResetRack not implemented")
}
func (UnimplementedRLAServer) ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedRLAServer) GetTasksByIDs(context.Context, *GetTasksByIDsRequest) (*GetTasksByIDsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTasksByIDs not implemented")
}
func (UnimplementedRLAServer) CreateOperationRule(context.Context, *CreateOperationRuleRequest) (*CreateOperationRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateOperationRule not implemented")
}
func (UnimplementedRLAServer) UpdateOperationRule(context.Context, *UpdateOperationRuleRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateOperationRule not implemented")
}
func (UnimplementedRLAServer) DeleteOperationRule(context.Context, *DeleteOperationRuleRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteOperationRule not implemented")
}
func (UnimplementedRLAServer) GetOperationRule(context.Context, *GetOperationRuleRequest) (*OperationRule, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOperationRule not implemented")
}
func (UnimplementedRLAServer) ListOperationRules(context.Context, *ListOperationRulesRequest) (*ListOperationRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOperationRules not implemented")
}
func (UnimplementedRLAServer) SetRuleAsDefault(context.Context, *SetRuleAsDefaultRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SetRuleAsDefault not implemented")
}
func (UnimplementedRLAServer) AssociateRuleWithRack(context.Context, *AssociateRuleWithRackRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AssociateRuleWithRack not implemented")
}
func (UnimplementedRLAServer) DisassociateRuleFromRack(context.Context, *DisassociateRuleFromRackRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DisassociateRuleFromRack not implemented")
}
func (UnimplementedRLAServer) GetRackRuleAssociation(context.Context, *GetRackRuleAssociationRequest) (*GetRackRuleAssociationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRackRuleAssociation not implemented")
}
func (UnimplementedRLAServer) ListRackRuleAssociations(context.Context, *ListRackRuleAssociationsRequest) (*ListRackRuleAssociationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRackRuleAssociations not implemented")
}
func (UnimplementedRLAServer) mustEmbedUnimplementedRLAServer() {}
func (UnimplementedRLAServer) testEmbeddedByValue()             {}

// UnsafeRLAServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RLAServer will
// result in compilation errors.
type UnsafeRLAServer interface {
	mustEmbedUnimplementedRLAServer()
}

func RegisterRLAServer(s grpc.ServiceRegistrar, srv RLAServer) {
	// If the following call panics, it indicates UnimplementedRLAServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RLA_ServiceDesc, srv)
}

func _RLA_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_CreateExpectedRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExpectedRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).CreateExpectedRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_CreateExpectedRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).CreateExpectedRack(ctx, req.(*CreateExpectedRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PatchRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PatchRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PatchRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PatchRack(ctx, req.(*PatchRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetRackInfoByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRackInfoByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetRackInfoByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetRackInfoByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetRackInfoByID(ctx, req.(*GetRackInfoByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetRackInfoBySerial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRackInfoBySerialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetRackInfoBySerial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetRackInfoBySerial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetRackInfoBySerial(ctx, req.(*GetRackInfoBySerialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetComponentInfoByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComponentInfoByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetComponentInfoByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetComponentInfoByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetComponentInfoByID(ctx, req.(*GetComponentInfoByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetComponentInfoBySerial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComponentInfoBySerialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetComponentInfoBySerial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetComponentInfoBySerial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetComponentInfoBySerial(ctx, req.(*GetComponentInfoBySerialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetListOfRacks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListOfRacksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetListOfRacks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetListOfRacks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetListOfRacks(ctx, req.(*GetListOfRacksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_CreateNVLDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNVLDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).CreateNVLDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_CreateNVLDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).CreateNVLDomain(ctx, req.(*CreateNVLDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_AttachRacksToNVLDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachRacksToNVLDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).AttachRacksToNVLDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_AttachRacksToNVLDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).AttachRacksToNVLDomain(ctx, req.(*AttachRacksToNVLDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_DetachRacksFromNVLDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachRacksFromNVLDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).DetachRacksFromNVLDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_DetachRacksFromNVLDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).DetachRacksFromNVLDomain(ctx, req.(*DetachRacksFromNVLDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetListOfNVLDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListOfNVLDomainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetListOfNVLDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetListOfNVLDomains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetListOfNVLDomains(ctx, req.(*GetListOfNVLDomainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetRacksForNVLDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRacksForNVLDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetRacksForNVLDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetRacksForNVLDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetRacksForNVLDomain(ctx, req.(*GetRacksForNVLDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_UpgradeFirmware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeFirmwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).UpgradeFirmware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_UpgradeFirmware_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).UpgradeFirmware(ctx, req.(*UpgradeFirmwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_BringUpRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BringUpRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).BringUpRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_BringUpRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).BringUpRack(ctx, req.(*BringUpRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComponentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetComponents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetComponents(ctx, req.(*GetComponentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_ValidateComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateComponentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).ValidateComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_ValidateComponents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).ValidateComponents(ctx, req.(*ValidateComponentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_AddComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddComponentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).AddComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_AddComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).AddComponent(ctx, req.(*AddComponentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PatchComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchComponentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PatchComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PatchComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PatchComponent(ctx, req.(*PatchComponentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_DeleteComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteComponentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).DeleteComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_DeleteComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).DeleteComponent(ctx, req.(*DeleteComponentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PowerOnRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerOnRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PowerOnRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PowerOnRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PowerOnRack(ctx, req.(*PowerOnRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PowerOffRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerOffRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PowerOffRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PowerOffRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PowerOffRack(ctx, req.(*PowerOffRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_PowerResetRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowerResetRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).PowerResetRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_PowerResetRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).PowerResetRack(ctx, req.(*PowerResetRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_ListTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).ListTasks(ctx, req.(*ListTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetTasksByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTasksByIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetTasksByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetTasksByIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetTasksByIDs(ctx, req.(*GetTasksByIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_CreateOperationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOperationRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).CreateOperationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_CreateOperationRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).CreateOperationRule(ctx, req.(*CreateOperationRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_UpdateOperationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOperationRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).UpdateOperationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_UpdateOperationRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).UpdateOperationRule(ctx, req.(*UpdateOperationRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_DeleteOperationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOperationRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).DeleteOperationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_DeleteOperationRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).DeleteOperationRule(ctx, req.(*DeleteOperationRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetOperationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetOperationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetOperationRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetOperationRule(ctx, req.(*GetOperationRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_ListOperationRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOperationRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).ListOperationRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_ListOperationRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).ListOperationRules(ctx, req.(*ListOperationRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_SetRuleAsDefault_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRuleAsDefaultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).SetRuleAsDefault(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_SetRuleAsDefault_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).SetRuleAsDefault(ctx, req.(*SetRuleAsDefaultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_AssociateRuleWithRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssociateRuleWithRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).AssociateRuleWithRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_AssociateRuleWithRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).AssociateRuleWithRack(ctx, req.(*AssociateRuleWithRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_DisassociateRuleFromRack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisassociateRuleFromRackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).DisassociateRuleFromRack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_DisassociateRuleFromRack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).DisassociateRuleFromRack(ctx, req.(*DisassociateRuleFromRackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_GetRackRuleAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRackRuleAssociationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).GetRackRuleAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_GetRackRuleAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).GetRackRuleAssociation(ctx, req.(*GetRackRuleAssociationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RLA_ListRackRuleAssociations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRackRuleAssociationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RLAServer).ListRackRuleAssociations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RLA_ListRackRuleAssociations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RLAServer).ListRackRuleAssociations(ctx, req.(*ListRackRuleAssociationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RLA_ServiceDesc is the grpc.ServiceDesc for RLA service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RLA_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.RLA",
	HandlerType: (*RLAServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _RLA_Version_Handler,
		},
		{
			MethodName: "CreateExpectedRack",
			Handler:    _RLA_CreateExpectedRack_Handler,
		},
		{
			MethodName: "PatchRack",
			Handler:    _RLA_PatchRack_Handler,
		},
		{
			MethodName: "GetRackInfoByID",
			Handler:    _RLA_GetRackInfoByID_Handler,
		},
		{
			MethodName: "GetRackInfoBySerial",
			Handler:    _RLA_GetRackInfoBySerial_Handler,
		},
		{
			MethodName: "GetComponentInfoByID",
			Handler:    _RLA_GetComponentInfoByID_Handler,
		},
		{
			MethodName: "GetComponentInfoBySerial",
			Handler:    _RLA_GetComponentInfoBySerial_Handler,
		},
		{
			MethodName: "GetListOfRacks",
			Handler:    _RLA_GetListOfRacks_Handler,
		},
		{
			MethodName: "CreateNVLDomain",
			Handler:    _RLA_CreateNVLDomain_Handler,
		},
		{
			MethodName: "AttachRacksToNVLDomain",
			Handler:    _RLA_AttachRacksToNVLDomain_Handler,
		},
		{
			MethodName: "DetachRacksFromNVLDomain",
			Handler:    _RLA_DetachRacksFromNVLDomain_Handler,
		},
		{
			MethodName: "GetListOfNVLDomains",
			Handler:    _RLA_GetListOfNVLDomains_Handler,
		},
		{
			MethodName: "GetRacksForNVLDomain",
			Handler:    _RLA_GetRacksForNVLDomain_Handler,
		},
		{
			MethodName: "UpgradeFirmware",
			Handler:    _RLA_UpgradeFirmware_Handler,
		},
		{
			MethodName: "BringUpRack",
			Handler:    _RLA_BringUpRack_Handler,
		},
		{
			MethodName: "GetComponents",
			Handler:    _RLA_GetComponents_Handler,
		},
		{
			MethodName: "ValidateComponents",
			Handler:    _RLA_ValidateComponents_Handler,
		},
		{
			MethodName: "AddComponent",
			Handler:    _RLA_AddComponent_Handler,
		},
		{
			MethodName: "PatchComponent",
			Handler:    _RLA_PatchComponent_Handler,
		},
		{
			MethodName: "DeleteComponent",
			Handler:    _RLA_DeleteComponent_Handler,
		},
		{
			MethodName: "PowerOnRack",
			Handler:    _RLA_PowerOnRack_Handler,
		},
		{
			MethodName: "PowerOffRack",
			Handler:    _RLA_PowerOffRack_Handler,
		},
		{
			MethodName: "PowerResetRack",
			Handler:    _RLA_PowerResetRack_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _RLA_ListTasks_Handler,
		},
		{
			MethodName: "GetTasksByIDs",
			Handler:    _RLA_GetTasksByIDs_Handler,
		},
		{
			MethodName: "CreateOperationRule",
			Handler:    _RLA_CreateOperationRule_Handler,
		},
		{
			MethodName: "UpdateOperationRule",
			Handler:    _RLA_UpdateOperationRule_Handler,
		},
		{
			MethodName: "DeleteOperationRule",
			Handler:    _RLA_DeleteOperationRule_Handler,
		},
		{
			MethodName: "GetOperationRule",
			Handler:    _RLA_GetOperationRule_Handler,
		},
		{
			MethodName: "ListOperationRules",
			Handler:    _RLA_ListOperationRules_Handler,
		},
		{
			MethodName: "SetRuleAsDefault",
			Handler:    _RLA_SetRuleAsDefault_Handler,
		},
		{
			MethodName: "AssociateRuleWithRack",
			Handler:    _RLA_AssociateRuleWithRack_Handler,
		},
		{
			MethodName: "DisassociateRuleFromRack",
			Handler:    _RLA_DisassociateRuleFromRack_Handler,
		},
		{
			MethodName: "GetRackRuleAssociation",
			Handler:    _RLA_GetRackRuleAssociation_Handler,
		},
		{
			MethodName: "ListRackRuleAssociations",
			Handler:    _RLA_ListRackRuleAssociations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rla.proto",
}
