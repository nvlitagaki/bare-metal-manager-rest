//
// SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: powershelf-manager.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PowershelfManager_RegisterPowershelves_FullMethodName    = "/v1.PowershelfManager/RegisterPowershelves"
	PowershelfManager_GetPowershelves_FullMethodName         = "/v1.PowershelfManager/GetPowershelves"
	PowershelfManager_UpdateFirmware_FullMethodName          = "/v1.PowershelfManager/UpdateFirmware"
	PowershelfManager_GetFirmwareUpdateStatus_FullMethodName = "/v1.PowershelfManager/GetFirmwareUpdateStatus"
	PowershelfManager_ListAvailableFirmware_FullMethodName   = "/v1.PowershelfManager/ListAvailableFirmware"
	PowershelfManager_SetDryRun_FullMethodName               = "/v1.PowershelfManager/SetDryRun"
	PowershelfManager_PowerOff_FullMethodName                = "/v1.PowershelfManager/PowerOff"
	PowershelfManager_PowerOn_FullMethodName                 = "/v1.PowershelfManager/PowerOn"
)

// PowershelfManagerClient is the client API for PowershelfManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PowershelfManager exposes registration, inventory, firmware management, and power control RPCs for power shelves via their PMCs.
type PowershelfManagerClient interface {
	// Registration
	// RegisterPowershelves registers the specified powershelves and persists their PMC credentials.
	RegisterPowershelves(ctx context.Context, in *RegisterPowershelvesRequest, opts ...grpc.CallOption) (*RegisterPowershelvesResponse, error)
	// Inventory Management
	// GetPowershelves returns powershelf information for all the powershelves requested.
	GetPowershelves(ctx context.Context, in *PowershelfRequest, opts ...grpc.CallOption) (*GetPowershelvesResponse, error)
	// Firmware Management
	// UpdateFirmware performs a firmware upgrade (supports dry-run).
	UpdateFirmware(ctx context.Context, in *UpdateFirmwareRequest, opts ...grpc.CallOption) (*UpdateFirmwareResponse, error)
	// GetFirmwareUpdateStatus returns the status of firmware updates for the specified PMC(s) and component(s).
	GetFirmwareUpdateStatus(ctx context.Context, in *GetFirmwareUpdateStatusRequest, opts ...grpc.CallOption) (*GetFirmwareUpdateStatusResponse, error)
	// ListAvailableFirmware lists the firmware versions that are available for a given powershelf.
	ListAvailableFirmware(ctx context.Context, in *PowershelfRequest, opts ...grpc.CallOption) (*ListAvailableFirmwareResponse, error)
	// SetDryRun configures whether the firmware manager is in Dry Run mode.
	SetDryRun(ctx context.Context, in *SetDryRunRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Power Control
	// Power OFF the rack
	PowerOff(ctx context.Context, in *PowershelfRequest, opts ...grpc.CallOption) (*PowerControlResponse, error)
	// Power ON the rack
	PowerOn(ctx context.Context, in *PowershelfRequest, opts ...grpc.CallOption) (*PowerControlResponse, error)
}

type powershelfManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewPowershelfManagerClient(cc grpc.ClientConnInterface) PowershelfManagerClient {
	return &powershelfManagerClient{cc}
}

func (c *powershelfManagerClient) RegisterPowershelves(ctx context.Context, in *RegisterPowershelvesRequest, opts ...grpc.CallOption) (*RegisterPowershelvesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterPowershelvesResponse)
	err := c.cc.Invoke(ctx, PowershelfManager_RegisterPowershelves_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powershelfManagerClient) GetPowershelves(ctx context.Context, in *PowershelfRequest, opts ...grpc.CallOption) (*GetPowershelvesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPowershelvesResponse)
	err := c.cc.Invoke(ctx, PowershelfManager_GetPowershelves_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powershelfManagerClient) UpdateFirmware(ctx context.Context, in *UpdateFirmwareRequest, opts ...grpc.CallOption) (*UpdateFirmwareResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateFirmwareResponse)
	err := c.cc.Invoke(ctx, PowershelfManager_UpdateFirmware_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powershelfManagerClient) GetFirmwareUpdateStatus(ctx context.Context, in *GetFirmwareUpdateStatusRequest, opts ...grpc.CallOption) (*GetFirmwareUpdateStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFirmwareUpdateStatusResponse)
	err := c.cc.Invoke(ctx, PowershelfManager_GetFirmwareUpdateStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powershelfManagerClient) ListAvailableFirmware(ctx context.Context, in *PowershelfRequest, opts ...grpc.CallOption) (*ListAvailableFirmwareResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAvailableFirmwareResponse)
	err := c.cc.Invoke(ctx, PowershelfManager_ListAvailableFirmware_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powershelfManagerClient) SetDryRun(ctx context.Context, in *SetDryRunRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PowershelfManager_SetDryRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powershelfManagerClient) PowerOff(ctx context.Context, in *PowershelfRequest, opts ...grpc.CallOption) (*PowerControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PowerControlResponse)
	err := c.cc.Invoke(ctx, PowershelfManager_PowerOff_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powershelfManagerClient) PowerOn(ctx context.Context, in *PowershelfRequest, opts ...grpc.CallOption) (*PowerControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PowerControlResponse)
	err := c.cc.Invoke(ctx, PowershelfManager_PowerOn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PowershelfManagerServer is the server API for PowershelfManager service.
// All implementations should embed UnimplementedPowershelfManagerServer
// for forward compatibility.
//
// PowershelfManager exposes registration, inventory, firmware management, and power control RPCs for power shelves via their PMCs.
type PowershelfManagerServer interface {
	// Registration
	// RegisterPowershelves registers the specified powershelves and persists their PMC credentials.
	RegisterPowershelves(context.Context, *RegisterPowershelvesRequest) (*RegisterPowershelvesResponse, error)
	// Inventory Management
	// GetPowershelves returns powershelf information for all the powershelves requested.
	GetPowershelves(context.Context, *PowershelfRequest) (*GetPowershelvesResponse, error)
	// Firmware Management
	// UpdateFirmware performs a firmware upgrade (supports dry-run).
	UpdateFirmware(context.Context, *UpdateFirmwareRequest) (*UpdateFirmwareResponse, error)
	// GetFirmwareUpdateStatus returns the status of firmware updates for the specified PMC(s) and component(s).
	GetFirmwareUpdateStatus(context.Context, *GetFirmwareUpdateStatusRequest) (*GetFirmwareUpdateStatusResponse, error)
	// ListAvailableFirmware lists the firmware versions that are available for a given powershelf.
	ListAvailableFirmware(context.Context, *PowershelfRequest) (*ListAvailableFirmwareResponse, error)
	// SetDryRun configures whether the firmware manager is in Dry Run mode.
	SetDryRun(context.Context, *SetDryRunRequest) (*emptypb.Empty, error)
	// Power Control
	// Power OFF the rack
	PowerOff(context.Context, *PowershelfRequest) (*PowerControlResponse, error)
	// Power ON the rack
	PowerOn(context.Context, *PowershelfRequest) (*PowerControlResponse, error)
}

// UnimplementedPowershelfManagerServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPowershelfManagerServer struct{}

func (UnimplementedPowershelfManagerServer) RegisterPowershelves(context.Context, *RegisterPowershelvesRequest) (*RegisterPowershelvesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterPowershelves not implemented")
}
func (UnimplementedPowershelfManagerServer) GetPowershelves(context.Context, *PowershelfRequest) (*GetPowershelvesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPowershelves not implemented")
}
func (UnimplementedPowershelfManagerServer) UpdateFirmware(context.Context, *UpdateFirmwareRequest) (*UpdateFirmwareResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateFirmware not implemented")
}
func (UnimplementedPowershelfManagerServer) GetFirmwareUpdateStatus(context.Context, *GetFirmwareUpdateStatusRequest) (*GetFirmwareUpdateStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFirmwareUpdateStatus not implemented")
}
func (UnimplementedPowershelfManagerServer) ListAvailableFirmware(context.Context, *PowershelfRequest) (*ListAvailableFirmwareResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAvailableFirmware not implemented")
}
func (UnimplementedPowershelfManagerServer) SetDryRun(context.Context, *SetDryRunRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDryRun not implemented")
}
func (UnimplementedPowershelfManagerServer) PowerOff(context.Context, *PowershelfRequest) (*PowerControlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PowerOff not implemented")
}
func (UnimplementedPowershelfManagerServer) PowerOn(context.Context, *PowershelfRequest) (*PowerControlResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PowerOn not implemented")
}
func (UnimplementedPowershelfManagerServer) testEmbeddedByValue() {}

// UnsafePowershelfManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PowershelfManagerServer will
// result in compilation errors.
type UnsafePowershelfManagerServer interface {
	mustEmbedUnimplementedPowershelfManagerServer()
}

func RegisterPowershelfManagerServer(s grpc.ServiceRegistrar, srv PowershelfManagerServer) {
	// If the following call panics, it indicates UnimplementedPowershelfManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PowershelfManager_ServiceDesc, srv)
}

func _PowershelfManager_RegisterPowershelves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterPowershelvesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowershelfManagerServer).RegisterPowershelves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PowershelfManager_RegisterPowershelves_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowershelfManagerServer).RegisterPowershelves(ctx, req.(*RegisterPowershelvesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowershelfManager_GetPowershelves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowershelfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowershelfManagerServer).GetPowershelves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PowershelfManager_GetPowershelves_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowershelfManagerServer).GetPowershelves(ctx, req.(*PowershelfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowershelfManager_UpdateFirmware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFirmwareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowershelfManagerServer).UpdateFirmware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PowershelfManager_UpdateFirmware_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowershelfManagerServer).UpdateFirmware(ctx, req.(*UpdateFirmwareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowershelfManager_GetFirmwareUpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFirmwareUpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowershelfManagerServer).GetFirmwareUpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PowershelfManager_GetFirmwareUpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowershelfManagerServer).GetFirmwareUpdateStatus(ctx, req.(*GetFirmwareUpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowershelfManager_ListAvailableFirmware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowershelfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowershelfManagerServer).ListAvailableFirmware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PowershelfManager_ListAvailableFirmware_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowershelfManagerServer).ListAvailableFirmware(ctx, req.(*PowershelfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowershelfManager_SetDryRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDryRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowershelfManagerServer).SetDryRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PowershelfManager_SetDryRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowershelfManagerServer).SetDryRun(ctx, req.(*SetDryRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowershelfManager_PowerOff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowershelfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowershelfManagerServer).PowerOff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PowershelfManager_PowerOff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowershelfManagerServer).PowerOff(ctx, req.(*PowershelfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowershelfManager_PowerOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PowershelfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowershelfManagerServer).PowerOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PowershelfManager_PowerOn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowershelfManagerServer).PowerOn(ctx, req.(*PowershelfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PowershelfManager_ServiceDesc is the grpc.ServiceDesc for PowershelfManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PowershelfManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.PowershelfManager",
	HandlerType: (*PowershelfManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterPowershelves",
			Handler:    _PowershelfManager_RegisterPowershelves_Handler,
		},
		{
			MethodName: "GetPowershelves",
			Handler:    _PowershelfManager_GetPowershelves_Handler,
		},
		{
			MethodName: "UpdateFirmware",
			Handler:    _PowershelfManager_UpdateFirmware_Handler,
		},
		{
			MethodName: "GetFirmwareUpdateStatus",
			Handler:    _PowershelfManager_GetFirmwareUpdateStatus_Handler,
		},
		{
			MethodName: "ListAvailableFirmware",
			Handler:    _PowershelfManager_ListAvailableFirmware_Handler,
		},
		{
			MethodName: "SetDryRun",
			Handler:    _PowershelfManager_SetDryRun_Handler,
		},
		{
			MethodName: "PowerOff",
			Handler:    _PowershelfManager_PowerOff_Handler,
		},
		{
			MethodName: "PowerOn",
			Handler:    _PowershelfManager_PowerOn_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "powershelf-manager.proto",
}
