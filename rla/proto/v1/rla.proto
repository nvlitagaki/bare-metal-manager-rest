/*
 * SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

package v1;
option go_package = "github.com/nvidia/bare-metal-manager-rest/rla/pkg/proto/v1";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

service RLA {
    // What version of RLA is this service running?
    rpc Version(VersionRequest) returns (BuildInfo);

    rpc CreateExpectedRack(CreateExpectedRackRequest) returns (CreateExpectedRackResponse);
    rpc PatchRack(PatchRackRequest) returns (PatchRackResponse);
    rpc GetRackInfoByID(GetRackInfoByIDRequest) returns (GetRackInfoResponse);
    rpc GetRackInfoBySerial(GetRackInfoBySerialRequest) returns (GetRackInfoResponse);
    rpc GetComponentInfoByID(GetComponentInfoByIDRequest) returns (GetComponentInfoResponse);
    rpc GetComponentInfoBySerial(GetComponentInfoBySerialRequest) returns (GetComponentInfoResponse);
    rpc GetListOfRacks(GetListOfRacksRequest) returns (GetListOfRacksResponse);
    rpc CreateNVLDomain(CreateNVLDomainRequest) returns (CreateNVLDomainResponse);
    rpc AttachRacksToNVLDomain(AttachRacksToNVLDomainRequest) returns (google.protobuf.Empty);
    rpc DetachRacksFromNVLDomain(DetachRacksFromNVLDomainRequest) returns (google.protobuf.Empty);
    rpc GetListOfNVLDomains(GetListOfNVLDomainsRequest) returns (GetListOfNVLDomainsResponse);
    rpc GetRacksForNVLDomain(GetRacksForNVLDomainRequest) returns (GetRacksForNVLDomainResponse);
    rpc UpgradeFirmware(UpgradeFirmwareRequest) returns (SubmitTaskResponse);

    // Bring up rack: power on, configure, and validate a new rack
    rpc BringUpRack(BringUpRackRequest) returns (SubmitTaskResponse);

    // Components APIs
    rpc GetComponents(GetComponentsRequest) returns (GetComponentsResponse);
    rpc ValidateComponents(ValidateComponentsRequest) returns (ValidateComponentsResponse);
    rpc AddComponent(AddComponentRequest) returns (AddComponentResponse);
    rpc PatchComponent(PatchComponentRequest) returns (PatchComponentResponse);
    rpc DeleteComponent(DeleteComponentRequest) returns (DeleteComponentResponse);

    // Power control a rack or a rack's specified components
    rpc PowerOnRack(PowerOnRackRequest) returns (SubmitTaskResponse);
    rpc PowerOffRack(PowerOffRackRequest) returns (SubmitTaskResponse);
    rpc PowerResetRack(PowerResetRackRequest) returns (SubmitTaskResponse);

    // Query for tasks
    rpc ListTasks(ListTasksRequest) returns (ListTasksResponse);
    rpc GetTasksByIDs(GetTasksByIDsRequest) returns (GetTasksByIDsResponse);

    // Operation rules management
    rpc CreateOperationRule(CreateOperationRuleRequest) returns (CreateOperationRuleResponse);
    rpc UpdateOperationRule(UpdateOperationRuleRequest) returns (google.protobuf.Empty);
    rpc DeleteOperationRule(DeleteOperationRuleRequest) returns (google.protobuf.Empty);
    rpc GetOperationRule(GetOperationRuleRequest) returns (OperationRule);
    rpc ListOperationRules(ListOperationRulesRequest) returns (ListOperationRulesResponse);
    rpc SetRuleAsDefault(SetRuleAsDefaultRequest) returns (google.protobuf.Empty);

    // Rack-rule associations
    rpc AssociateRuleWithRack(AssociateRuleWithRackRequest) returns (google.protobuf.Empty);
    rpc DisassociateRuleFromRack(DisassociateRuleFromRackRequest) returns (google.protobuf.Empty);
    rpc GetRackRuleAssociation(GetRackRuleAssociationRequest) returns (GetRackRuleAssociationResponse);
    rpc ListRackRuleAssociations(ListRackRuleAssociationsRequest) returns (ListRackRuleAssociationsResponse);
}

message UUID {
    string id = 1;
}

message DeviceInfo {
    UUID id = 1;
    string name = 2;
    string manufacturer = 3;
    optional string model = 4;
    string serial_number = 5;
    optional string description = 6;
}

message Location {
    string region = 1;
    string datacenter = 2;
    string room = 3;
    string position = 4;
}

message DeviceSerialInfo {
    string manufacturer = 1;
    string serial_number = 2;
}

enum BMCType {
    BMC_TYPE_UNKNOWN = 0;
    BMC_TYPE_HOST = 1;
    BMC_TYPE_DPU = 2;
}

message BMCInfo {
    BMCType type = 1;
    string mac_address = 2;
    optional string ip_address = 3;
    optional string user = 4;
    optional string password = 5;
}

message RackPosition {
    int32 slot_id = 1;
    int32 tray_idx = 2;
    int32 host_id = 3; 
}

enum ComponentType {
    COMPONENT_TYPE_UNKNOWN = 0;
    COMPONENT_TYPE_COMPUTE = 1;
    COMPONENT_TYPE_NVLSWITCH = 2;
    COMPONENT_TYPE_POWERSHELF = 3;
    COMPONENT_TYPE_TORSWITCH = 4;
    COMPONENT_TYPE_UMS = 5;
    COMPONENT_TYPE_CDU = 6;
}

// RackFilterField represents the supported filter field types for rack queries
enum RackFilterField {
    RACK_FILTER_FIELD_UNSPECIFIED = 0;
    RACK_FILTER_FIELD_NAME = 1;           // Filter by rack name
    RACK_FILTER_FIELD_MANUFACTURER = 2;   // Filter by manufacturer
    RACK_FILTER_FIELD_MODEL = 3;          // Filter by model (stored in description JSONB)
}

// ComponentFilterField represents the supported filter field types for component queries
enum ComponentFilterField {
    COMPONENT_FILTER_FIELD_UNSPECIFIED = 0;
    COMPONENT_FILTER_FIELD_NAME = 1;           // Filter by component name
    COMPONENT_FILTER_FIELD_MANUFACTURER = 2;   // Filter by manufacturer
    COMPONENT_FILTER_FIELD_MODEL = 3;          // Filter by model (stored in description JSONB)
    COMPONENT_FILTER_FIELD_TYPE = 4;           // Filter by component type (use ComponentType enum string values in StringQueryInfo)
}

// ComponentOrderByField represents the supported order by field types for component queries
enum ComponentOrderByField {
    COMPONENT_ORDER_BY_FIELD_UNSPECIFIED = 0;
    COMPONENT_ORDER_BY_FIELD_NAME = 1;         // Order by component name
    COMPONENT_ORDER_BY_FIELD_MANUFACTURER = 2; // Order by manufacturer
    COMPONENT_ORDER_BY_FIELD_MODEL = 3;        // Order by model
    COMPONENT_ORDER_BY_FIELD_TYPE = 4;         // Order by component type
}

// RackOrderByField represents the supported order by field types for rack queries
enum RackOrderByField {
    RACK_ORDER_BY_FIELD_UNSPECIFIED = 0;
    RACK_ORDER_BY_FIELD_NAME = 1;              // Order by rack name
    RACK_ORDER_BY_FIELD_MANUFACTURER = 2;      // Order by manufacturer
    RACK_ORDER_BY_FIELD_MODEL = 3;             // Order by model
}

enum PowerControlOp {
    POWER_CONTROL_OP_UNKNOWN = 0;
    // Power On
    POWER_CONTROL_OP_ON = 1;
    POWER_CONTROL_OP_FORCE_ON = 2;
    // Power Off
    POWER_CONTROL_OP_OFF = 3;            // graceful shutdown
    POWER_CONTROL_OP_FORCE_OFF = 4;
    // Restart (OS level reboot)
    POWER_CONTROL_OP_RESTART = 5;        // graceful restart
    POWER_CONTROL_OP_FORCE_RESTART = 6;
    // Reset (hardware level)
    POWER_CONTROL_OP_WARM_RESET = 7;
    POWER_CONTROL_OP_COLD_RESET = 8;
}

enum TaskStatus {
    TASK_STATUS_UNKNOWN = 0;
    TASK_STATUS_PENDING = 1;
    TASK_STATUS_RUNNING = 2;
    TASK_STATUS_COMPLETED = 3;
    TASK_STATUS_FAILED = 4;
}

enum TaskExecutorType {
    TASK_EXECUTOR_TYPE_UNKNOWN = 0;
    TASK_EXECUTOR_TYPE_TEMPORAL = 1;
}

message Component {
    ComponentType type = 1;
    DeviceInfo info = 2;
    string firmware_version = 3;
    RackPosition position = 4;
    repeated BMCInfo bmcs = 5;
    string component_id = 6;  // Component's own ID from its source system (e.g., Carbide machine_id for Compute)
    UUID rack_id = 7;
    string power_state = 8;  // Current power state (synced from external system by inventory loop)
}

message Rack {
    DeviceInfo info = 1;
    Location location = 2;
    repeated Component components = 3;
}

message Identifier {
    UUID id = 1;
    string name = 2;
}

// OperationTargetSpec contains targets for an operation.
// Supports either rack-level targeting (with optional type filtering)
// or component-level targeting (by UUID or external reference), but not both.
message OperationTargetSpec {
    oneof targets {
        RackTargets racks = 1;
        ComponentTargets components = 2;
    }
}

// RackTargets contains one or more rack targets
message RackTargets {
    repeated RackTarget targets = 1;
}

// ComponentTargets contains one or more component targets
message ComponentTargets {
    repeated ComponentTarget targets = 1;
}

// RackTarget identifies a rack and optionally filters by component types
message RackTarget {
    oneof identifier {
        UUID id = 1;        // Rack UUID
        string name = 2;    // Rack name
    }
    // Optional: component types to include. Empty = ALL components in rack
    repeated ComponentType component_types = 3;
}

// ComponentTarget identifies a specific component
message ComponentTarget {
    oneof identifier {
        UUID id = 1;           // Component UUID
        ExternalRef external = 2;  // External system reference
    }
}

// ExternalRef identifies a component by its external system ID.
// The component type determines which external system to query
// (e.g., COMPUTE -> Carbide, POWERSHELF -> PSM)
message ExternalRef {
    ComponentType type = 1;  // Component type determines the source system
    string id = 2;           // ID in that system (e.g., Carbide machine_id, PSM PMC MAC)
}

message NVLDomain {
    Identifier identifier = 1;
}

message Pagination {
    int32 offset = 1;
    int32 limit = 2;
}

message StringQueryInfo {
    repeated string patterns = 1;
    bool is_wildcard = 2;
    bool use_or = 3;
}

// Filter represents a single filter condition
message Filter {
    oneof field {
        RackFilterField rack_field = 1;           // For rack queries
        ComponentFilterField component_field = 2;  // For component queries
    }
    StringQueryInfo query_info = 3;
}

// OrderBy represents ordering specification
message OrderBy {
    oneof field {
        RackOrderByField rack_field = 1;           // For rack queries
        ComponentOrderByField component_field = 2; // For component queries
    }
    string direction = 3;  // ASC or DESC
}

message Task {
    UUID id = 1;
    string operation = 2;
    UUID rack_id = 3;
    repeated UUID component_uuids = 4;
    string description = 5;
    TaskExecutorType executor_type = 6;
    string execution_id = 7;
    TaskStatus status = 8;
    string message = 9;
}

message CreateExpectedRackRequest {
    Rack rack = 1;
}

message CreateExpectedRackResponse {
    UUID id = 1;
}

message GetRackInfoByIDRequest {
    UUID id = 1;
    bool with_components = 2;
}

message GetRackInfoBySerialRequest {
    DeviceSerialInfo serial_info = 1;
    bool with_components = 2;
}

message GetRackInfoResponse {
    Rack rack = 1;
}

message PatchRackRequest {
    Rack rack = 1;
}

message PatchRackResponse {
    string report = 1;
}

message GetComponentInfoByIDRequest {
    UUID id = 1;
    bool with_rack = 2;
}

message GetComponentInfoBySerialRequest {
    DeviceSerialInfo serial_info = 1;
    bool with_rack = 2;
}

message GetComponentInfoResponse {
    Component component = 1;
    Rack rack = 2;
}

message GetListOfRacksRequest {
    repeated Filter filters = 1;  // Filter conditions for rack queries
    bool with_components = 2;
    optional Pagination pagination = 3;
    optional OrderBy order_by = 4;
}

message GetListOfRacksResponse {
    repeated Rack racks = 1;
    int32 total = 2;
}

message CreateNVLDomainRequest {
    NVLDomain nvl_domain = 1;
}

message CreateNVLDomainResponse {
    UUID id = 1;
}

message AttachRacksToNVLDomainRequest {
    Identifier nvl_domain_identifier = 1;
    repeated Identifier rack_identifiers = 2;
}

message DetachRacksFromNVLDomainRequest {
    repeated Identifier rack_identifiers = 1;
}

message GetListOfNVLDomainsRequest {
    StringQueryInfo info = 1;
    optional Pagination pagination = 2;
}

message GetListOfNVLDomainsResponse {
    repeated NVLDomain nvl_domains = 1;
    int32 total = 2;
}

message GetRacksForNVLDomainRequest {
    Identifier nvl_domain_identifier = 1;
}

message GetRacksForNVLDomainResponse {
    repeated Rack racks = 1;
}

message UpgradeFirmwareRequest {
    OperationTargetSpec target_spec = 1;             // required: identifies components to upgrade
    optional string target_version = 2;              // optional: target firmware version
    optional google.protobuf.Timestamp start_time = 3;  // optional: scheduled start time
    optional google.protobuf.Timestamp end_time = 4;    // optional: scheduled end time
    string description = 5;                          // optional: task description
}

// GetComponents - retrieves components from local database
message GetComponentsRequest {
    optional OperationTargetSpec target_spec = 1;   // Optional: Flexible targeting: rack(s) with optional type filter, or specific components. If not provided, queries all components.
    repeated Filter filters = 2;  // Filter conditions for component queries
    optional Pagination pagination = 3;
    optional OrderBy order_by = 4;
}

message GetComponentsResponse {
    repeated Component components = 1;
    int32 total = 2;
}

message ValidateComponentsRequest {
    optional OperationTargetSpec target_spec = 1;   // Optional: Flexible targeting: rack(s) with optional type filter, or specific components. If not provided, returns all drifts.
    repeated Filter filters = 2;           // Filter conditions for component queries
    optional Pagination pagination = 3;
    optional OrderBy order_by = 4;
}

message ValidateComponentsResponse {
    repeated ComponentDiff diffs = 1;
    int32 total_diffs = 2;
    
    // Summary counts
    int32 only_in_expected_count = 3;
    int32 only_in_actual_count = 4;
    int32 drift_count = 5;
    int32 match_count = 6;
}

enum DiffType {
    DIFF_TYPE_UNKNOWN = 0;
    DIFF_TYPE_ONLY_IN_EXPECTED = 1;  // In local DB but not in source system
    DIFF_TYPE_ONLY_IN_ACTUAL = 2;    // In source system but not in local DB
    DIFF_TYPE_DRIFT = 3;              // In both but with field differences
}

message ComponentDiff {
    DiffType type = 1;
    string component_id = 2;
    
    // Populated when type is ONLY_IN_EXPECTED or ONLY_IN_ACTUAL
    Component expected = 3;
    Component actual = 4;
    
    // Populated when type is DRIFT - lists the fields that differ
    repeated FieldDiff field_diffs = 5;
}

message FieldDiff {
    string field_name = 1;      // e.g., "position.slot_id", "firmware_version"
    string expected_value = 2;
    string actual_value = 3;
}

// AddComponent - add a single component to an existing rack
message AddComponentRequest {
    Component component = 1;              // Required: the component to add; component.rack_id must be set
}

message AddComponentResponse {
    Component component = 1;  // The created component
}

// DeleteComponent - soft-delete a single component by UUID
message DeleteComponentRequest {
    UUID id = 1;  // Required: component UUID to delete
}

message DeleteComponentResponse {}

// PatchComponent - update a single component's fields
message PatchComponentRequest {
    UUID id = 1;                          // Required: component UUID
    optional string firmware_version = 2; // Update firmware version
    optional RackPosition position = 3;   // Update slot_id, tray_idx, host_id
    optional string description = 4;      // Update description (JSON string)
    optional UUID rack_id = 5;            // Re-assign to a different rack
}

message PatchComponentResponse {
    Component component = 1;  // The updated component
}

message SubmitTaskResponse {
    repeated UUID task_ids = 1;  // Multiple task IDs (1 task per rack)
}

message PowerOnRackRequest {
    OperationTargetSpec target_spec = 1;  // Flexible targeting: rack(s) with optional type filter, or specific components
    string description = 2;               // optional task description
}

message PowerOffRackRequest {
    OperationTargetSpec target_spec = 1;  // Flexible targeting: rack(s) with optional type filter, or specific components
    bool forced = 2;
    string description = 3;               // optional task description
}

message PowerResetRackRequest {
    OperationTargetSpec target_spec = 1;  // Flexible targeting: rack(s) with optional type filter, or specific components
    bool forced = 2;
    string description = 3;               // optional task description
}

message BringUpRackRequest {
    OperationTargetSpec target_spec = 1;  // Target racks for bring-up
    string description = 2;               // optional task description
}

message ListTasksRequest {
    optional UUID rack_id = 1;
    bool active_only = 2;
    optional Pagination pagination = 3;
}

message ListTasksResponse {
    repeated Task tasks = 1;
    int32 total = 2;
}

message GetTasksByIDsRequest {
    repeated UUID task_ids = 1;
}

message GetTasksByIDsResponse {
    repeated Task tasks = 1;
}

// Version API messages
message VersionRequest {}

message BuildInfo {
    string version = 1;      // e.g., v2025.11.19
    string build_time = 2;   // e.g., 2025-01-27T10:30:00Z
    string git_commit = 3;   // e.g., abc1234
}

// Operation Rules API messages

enum OperationType {
    OPERATION_TYPE_UNKNOWN = 0;
    OPERATION_TYPE_POWER_CONTROL = 1;
    OPERATION_TYPE_FIRMWARE_CONTROL = 2;
}

message OperationRule {
    UUID id = 1;
    string name = 2;
    string description = 3;
    OperationType operation_type = 4;
    string operation_code = 5;  // Specific operation code (e.g., "power_on", "upgrade")
    string rule_definition_json = 6;  // JSON-encoded RuleDefinition
    bool is_default = 7;
    google.protobuf.Timestamp created_at = 8;
    google.protobuf.Timestamp updated_at = 9;
}

message CreateOperationRuleRequest {
    string name = 1;
    string description = 2;
    OperationType operation_type = 3;
    string operation_code = 4;  // Specific operation code (e.g., "power_on", "upgrade")
    string rule_definition_json = 5;  // JSON-encoded RuleDefinition
    bool is_default = 6;
}

message CreateOperationRuleResponse {
    UUID id = 1;
}

message UpdateOperationRuleRequest {
    UUID rule_id = 1;
    optional string name = 2;
    optional string description = 3;
    optional string rule_definition_json = 4;  // JSON-encoded RuleDefinition
    // Note: is_default is NOT updatable here - use SetRuleAsDefault instead
}

message DeleteOperationRuleRequest {
    UUID rule_id = 1;
}

message SetRuleAsDefaultRequest {
    UUID rule_id = 1;
}

message GetOperationRuleRequest {
    UUID rule_id = 1;
}

message ListOperationRulesRequest {
    optional OperationType operation_type = 1;
    optional bool is_default = 2;
    optional int32 offset = 3;
    optional int32 limit = 4;
}

message ListOperationRulesResponse {
    repeated OperationRule rules = 1;
    int32 total_count = 2;
}

// Rack-rule associations API messages

message AssociateRuleWithRackRequest {
    UUID rack_id = 1;
    UUID rule_id = 2;
}

message DisassociateRuleFromRackRequest {
    UUID rack_id = 1;
    OperationType operation_type = 2;
    string operation_code = 3;  // Specific operation code
}

message GetRackRuleAssociationRequest {
    UUID rack_id = 1;
    OperationType operation_type = 2;
    string operation_code = 3;  // Specific operation code
}

message GetRackRuleAssociationResponse {
    UUID rule_id = 1;  // Empty if no association exists
}

message ListRackRuleAssociationsRequest {
    UUID rack_id = 1;
}

message RackRuleAssociation {
    UUID rack_id = 1;
    OperationType operation_type = 2;
    string operation_code = 3;  // Specific operation code (e.g., "power_on", "upgrade")
    UUID rule_id = 4;
    google.protobuf.Timestamp created_at = 5;
    google.protobuf.Timestamp updated_at = 6;
}

message ListRackRuleAssociationsResponse {
    repeated RackRuleAssociation associations = 1;
}
